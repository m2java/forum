Статьи

ПЕрвая статья

Название: Знай сложности алгоритмов

<div>
 Эта статья рассказывает о времени выполнения и о расходе памяти большинства алгоритмов используемых в информатике. В прошлом, когда я готовился к прохождению собеседования я потратил много времени исследуя интернет для поиска информации о лучшем, среднем и худшем случае работы алгоритмов поиска и сортировки, чтобы заданный вопрос на собеседовании не поставил меня в тупик. За последние несколько лет я проходил интервью в нескольких стартапах из Силиконовой долины, а также в некоторых крупных компаниях таких как Yahoo, eBay, LinkedIn и Google и каждый раз, когда я готовился к интервью, я подумал: «Почему никто не создал хорошую шпаргалку по асимптотической сложности алгоритмов? ». Чтобы сохранить ваше время я создал такую шпаргалку. Наслаждайтесь!
 <br>
 <a></a>
 <br>
 <img src="https://habrastorage.org/getpro/habr/post_images/3da/386/eed/3da386eed54c16ff73b647b383aea085.png">
 <br>
 <br>
 <h4>Поиск</h4>
 <br>
 <img src="https://habrastorage.org/getpro/habr/post_images/f54/446/a54/f54446a54f3d52d20e95ba5c5495644f.png">
 <br>
 <br>
 <h4>Сортировка</h4>
 <br>
 <img src="https://habrastorage.org/getpro/habr/post_images/b91/1bc/ca9/b911bcca9ca9f9d8b0fa781a49118553.png">
 <br>
 <br>
 <h4>Структуры данных</h4>
 <br>
 <img src="https://habrastorage.org/getpro/habr/post_images/9a5/f72/788/9a5f72788d9e0e5ac0d0e585e3b3632f.png">
 <br>
 <br>
 <h4>Кучи</h4>
 <br>
 <img src="https://habrastorage.org/getpro/habr/post_images/373/6d4/4e7/3736d44e79e3bf542e2a847bbedcf86d.png">
 <br>
 <br>
 <h4>Представление графов</h4>
 <br> Пусть дан граф с |V| вершинами и |E| ребрами, тогда
 <br>
 <br>
 <img src="https://habrastorage.org/getpro/habr/post_images/2da/7ae/feb/2da7aefeb058082fd3eaf1599f9500f8.png">
 <br>
 <br>
 <h4>Нотация асимптотического роста</h4>
 <br>
 <img src="https://habrastorage.org/getpro/habr/post_images/fd0/c1c/9ed/fd0c1c9ed7d949c2cd258b45302016ca.png">
 <br>
 <br>
 <ol>
  <li> (О — большое) — верхняя граница, в то время как (Омега — большое) — нижняя граница. Тета требует как (О — большое), так и (Омега — большое), поэтому она является точной оценкой (она должна быть ограничена как сверху, так и снизу). К примеру, алгоритм требующий Ω (n logn) требует не менее n logn времени, но верхняя граница не известна. Алгоритм требующий Θ (n logn) предпочтительнее потому, что он требует не менее n logn (Ω (n logn)) и не более чем n logn (O(n logn)).</li>
  <li>f(x)=Θ(g(n)) означает, что f растет так же как и g когда n стремится к бесконечности. Другими словами, скорость роста f(x) асимптотически пропорциональна скорости роста g(n).</li>
  <li>f(x)=O(g(n)). Здесь темпы роста не быстрее, чем g (n). O большое является наиболее полезной, поскольку представляет наихудший случай.</li>
 </ol>
 <br> Короче говоря, если алгоритм имеет сложность __ тогда его эффективность __
 <br>
 <img src="https://habrastorage.org/getpro/habr/post_images/17c/a73/d8d/17ca73d8dad367e1a60e3e20281e9d6d.png">
 <br>
 <br>
 <h4>График роста O — большое</h4>
 <br>
 <img src="https://habrastorage.org/getpro/habr/post_images/195/e1f/6a1/195e1f6a1379554ca9025338301a78ed.png">
</div>


Вторая статья

Название: Новое в Java 8


Добро пожаловать в ведение по <a href="https://jdk8.java.net/">Java 8</a>. Этот материал шаг за шагом познакомит вас со всеми новыми фичами языка. Вы научитесь использовать методы интерфейсов по умолчанию (default interface methods), лямбда-выражения (lambda expressions), ссылки на методы (method references) и повторяемые аннотации (repeatable annotations). Все это будет сопровождаться короткими и простыми примерами кода. В конце статьи вы познакомитесь с наиболее свежими изменениями в <a href="http://download.java.net/jdk8/docs/api/">API</a>, касающихся потоков, функциональных интерфейсов, расширений для ассоциативных массивов, а также с изменениями в API работы с датами.<br/>
<a name="habracut"></a><br/>
<h4>Методы интерфейсов по умолчанию</h4><br/>
Java 8 позволяет вам добавлять неабстрактные реализации методов в интерфейс, используя ключевое слово <code>default</code>. Эта фича также известна, как методы расширения. Вот наш первый пример:<br/>
<br/>
<pre><code class="java">interface Formula {
    double calculate(int a);

    default double sqrt(int a) {
        return Math.sqrt(a);
    }
}
</code></pre><br/>
Кроме абстрактного метода <code>calculate</code> интерфейс <code>Formula</code> также определяет метод по умолчанию <code>sqrt</code>. Классы, имплементирующие этот интерфейс, должны переопределить только абстрактный метод <code>calculate</code>. Метод по умолчанию <code>sqrt</code> будет доступен без переопределения.<br/>
<br/>
<pre><code class="java">Formula formula = new Formula() {
    @Override
    public double calculate(int a) {
        return sqrt(a * 100);
    }
};

formula.calculate(100);     // 100.0
formula.sqrt(16);                // 4.0
</code></pre><br/>
<code>formula</code> реализован как анонимный объект. Этот код довольно избыточен: целых 6 строчек для такого простого вычисления как <code>sqrt(a * 100)</code>. В следующем разделе мы увидим, что в Java 8 есть куда более изящный способ реализации объектов с одним методом.<br/>
<br/>
<h4>Лямбда-выражения</h4><br/>
Давайте начнем с простого примера: сортировка массива строк в предыдущих версиях языка.<br/>
<br/>
<pre><code class="java">List&lt;String&gt; names = Arrays.asList(&quot;peter&quot;, &quot;anna&quot;, &quot;mike&quot;, &quot;xenia&quot;);

Collections.sort(names, new Comparator&lt;String&gt;() {
    @Override
    public int compare(String a, String b) {
        return b.compareTo(a);
    }
});
</code></pre><br/>
Статический метод <code>Collections.sort</code> принимает список и компаратор, который используется для сортировки списка. Наверняка вам часто приходилось создавать анонимные компараторы для того чтобы передать их в метод.<br/>
<br/>
Java 8 предоставляет гораздо более короткий синтаксис — лямбда-выражения, чтобы вам не приходилось тратить время на создание анонимных объектов:<br/>
<br/>
<pre><code class="java">Collections.sort(names, (String a, String b) -&gt; {
    return b.compareTo(a);
});
</code></pre><br/>
Как видите, код гораздо короче и куда более читаем. И его можно сделать еще короче:<br/>
<br/>
<pre><code class="java">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));
</code></pre><br/>
Для однострочных методов вы можете опустить скобки {} и ключевое слово <code>return</code>. Так еще короче:<br/>
<br/>
<pre><code class="java">Collections.sort(names, (a, b) -&gt; b.compareTo(a));
</code></pre><br/>
Компилятору известны типы параметров, поэтому их можно тоже опустить. Давайте посмотрим, как еще могут использовать лямбда-выражения.<br/>
<br/>
<h4>Функциональные интерфейсы</h4><br/>
Как лямбда-выражения соответствуют системе типов языка Java? Каждой лямбде соответствует тип, представленный интерфейсом. Так называемый <i>функциональный интерфейс</i> должен содержать <b>ровно один абстрактный метод</b>. Каждое лямбда-выражение этого типа будет сопоставлено объявленному методу. Также, поскольку методы по умолчанию не являются абстрактными, вы можете добавлять в функциональный интерфейс сколько угодно таких методов.<br/>
<br/>
Мы можем использовать какие угодно интерфейсы для лямбда-выражений, содержащие ровно один абстрактный метод. Для того, чтобы гарантировать, что ваш интерфейс отвечает этому требованию, используется аннотация <code>@FunctionalInterface</code>. Компилятор осведомлен об этой аннотации, и выдаст ошибку компиляции, если вы добавите второй абстрактный метод в функциональный интерфейс.<br/>
<br/>
Пример:<br/>
<br/>
<pre><code class="java">@FunctionalInterface
interface Converter&lt;F, T&gt; {
    T convert(F from);
}
</code></pre><br/>
<pre><code class="java">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);
Integer converted = converter.convert(&quot;123&quot;);
System.out.println(converted);    // 123
</code></pre><br/>
Имейте в виду, что этот код останется корректным даже если убрать аннотацию <code>@FunctionalInterface</code>.<br/>
<br/>
<h4>Ссылки на методы и конструкторы</h4><br/>
Предыдущий пример можно упростить, если использовать статические ссылки на методы:<br/>
<br/>
<pre><code class="java">Converter&lt;String, Integer&gt; converter = Integer::valueOf;
Integer converted = converter.convert(&quot;123&quot;);
System.out.println(converted);   // 123
</code></pre><br/>
Java 8 позволяет вам передавать ссылки на методы или конструкторы. Для этого нужно использовать ключевое слово <code>::</code>. Предыдущий пример иллюстрирует передачу ссылки на статический метод. Однако мы также можем ссылаться на экземплярный метод:<br/>
<br/>
<pre><code class="java">class Something {
    String startsWith(String s) {
        return String.valueOf(s.charAt(0));
    }
}
</code></pre><br/>
<pre><code class="java">Something something = new Something();
Converter&lt;String, String&gt; converter = something::startsWith;
String converted = converter.convert(&quot;Java&quot;);
System.out.println(converted);    // &quot;J&quot;
</code></pre><br/>
Давайте посмотрим, как передавать ссылки на конструкторы. Сперва определим бин с несколькими конструкторами:<br/>
<br/>
<pre><code class="java">class Person {
    String firstName;
    String lastName;

    Person() {}

    Person(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
}
</code></pre><br/>
Затем определим интерфейс фабрики, которая будет использоваться для создания новых персон:<br/>
<br/>
<pre><code class="java">interface PersonFactory&lt;P extends Person&gt; {
    P create(String firstName, String lastName);
}
</code></pre><br/>
Теперь вместо реализации интерфейса мы соединяем все вместе при помощи ссылки на конструктор:<br/>
<br/>
<pre><code class="java">PersonFactory&lt;Person&gt; personFactory = Person::new;
Person person = personFactory.create(&quot;Peter&quot;, &quot;Parker&quot;);
</code></pre><br/>
Мы создаем ссылку на конструктор с помощью <code>Person::new</code>. Компилятор автоматически выбирает подходящий конструктор, сигнатура которого совпадает с сигнатурой <code>PersonFactory.create</code>.<br/>
<br/>
<h4>Области действия лямбд</h4><br/>
Доступ к переменным внешней области действия из лямбда-выражения очень схож к доступу из анонимных объектов. Вы можете ссылаться на переменные, объявленные как <code>final</code>, на экземплярные поля класса и статические переменные.<br/>
<br/>
<pre><code class="java">final int num = 1;
Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num);

stringConverter.convert(2);     // 3
</code></pre><br/>
Но в отличии от анонимных объектов, переменная <code>num</code> не обязательно должна быть объявлена как <code>final</code>. Такой код тоже сработает:<br/>
<br/>
<pre><code class="java">int num = 1;
Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num);

stringConverter.convert(2);     // 3
</code></pre><br/>
Однако переменная <code>num</code> должна все равно оставаться неизменяемой. Следующий код <b>не</b> скомпилируется:<br/>
<br/>
<pre><code class="java">int num = 1;
Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num);
num = 3;
</code></pre><br/>
Запись в переменную <code>num</code> в пределах лямбда-выражения также запрещена.<br/>
<br/>
<h5>Доступ к полям и статическим переменным</h5><br/>
В отличии от локальных переменных, мы можем записывать значения в экземплярные поля класса и статические переменные внутри лямбда-выражений. Это поведение хорошо знакомо по анонимным объектам.<br/>
<br/>
<pre><code class="java">class Lambda4 {
    static int outerStaticNum;
    int outerNum;

    void testScopes() {
        Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; {
            outerNum = 23;
            return String.valueOf(from);
        };

        Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; {
            outerStaticNum = 72;
            return String.valueOf(from);
        };
    }
}
</code></pre><br/>
<h5>Доступ к методам интерфейсов по умолчанию</h5><br/>
Помните пример с формулой из первого раздела? В интерфейсе <code>Formula</code> определен метод по умолчанию <code>sqrt</code>, который доступен из каждой имплементации интерфейса, включая анонимные объекты. Однако это не сработает в лямбда-выражениях.<br/>
<br/>
Внутри лямбда-выражений запрещено обращаться к методам по умолчанию. Следующий код не скомпилируется:<br/>
<br/>
<pre><code class="java">Formula formula = (a) -&gt; sqrt( a * 100);
</code></pre><br/>
<h4>Встроенные функциональные интерфейсы</h4><br/>
JDK 1.8 содержит множество встроенных функциональных интерфейсов. Некоторые из них хорошо известны по предыдущим версиям языка, например, <code>Comparator</code> или <code>Runnable</code>. Все эти интерфейсы были поддержаны в лямбдах добавлением аннотации <code>@FunctionalInterface</code>.<br/>
<br/>
Однако в Java 8 также появилось много новых функциональных интерфейсов, которые призваны облегчить вам жизнь. Некоторые интерфейсы хорошо известны по библиотеке Google Guava. Даже если вы незнакомы с этой библиотекой, вам стоить взглянуть, как эти интерфейсы были дополнены некоторыми полезными методами расширений.<br/>
<br/>
<h5>Предикаты</h5><br/>
Предикаты — это функции, принимающие один аргумент, и возвращающие значение типа boolean. Интерфейс содержит различные методы по умолчанию, позволяющие строить сложные условия (<code>and</code>, <code>or</code>, <code>negate</code>).<br/>
<br/>
<pre><code class="java">Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0;

predicate.test(&quot;foo&quot;);              // true
predicate.negate().test(&quot;foo&quot;);     // false

Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;
Predicate&lt;Boolean&gt; isNull = Objects::isNull;

Predicate&lt;String&gt; isEmpty = String::isEmpty;
Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();
</code></pre><br/>
<h5>Функции</h5><br/>
Функции принимают один аргумент и возвращают некоторый результат. Методы по умолчанию могут использоваться для построения цепочек вызовов (<code>compose</code>, <code>andThen</code>).<br/>
<br/>
<pre><code class="java">Function&lt;String, Integer&gt; toInteger = Integer::valueOf;
Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);

backToString.apply(&quot;123&quot;);     // &quot;123&quot;
</code></pre><br/>
<h5>Поставщики</h5><br/>
Поставщики (suppliers) предоставляют результат заданного типа. В отличии от функций, поставщики не принимают аргументов.<br/>
<br/>
<pre><code class="java">Supplier&lt;Person&gt; personSupplier = Person::new;
personSupplier.get();   // new Person
</code></pre><br/>
<h5>Потребители</h5><br/>
Потребители (consumers) представляют собой операции, которые производятся на одним входным аргументом.<br/>
<br/>
<pre><code class="java">Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(&quot;Hello, &quot; + p.firstName);
greeter.accept(new Person(&quot;Luke&quot;, &quot;Skywalker&quot;));
</code></pre><br/>
<h5>Компараторы</h5><br/>
Компараторы хорошо известны по предыдущим версиям Java. Java 8 добавляет в интерфейс различные методы по умолчанию.<br/>
<br/>
<pre><code class="java">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);

Person p1 = new Person(&quot;John&quot;, &quot;Doe&quot;);
Person p2 = new Person(&quot;Alice&quot;, &quot;Wonderland&quot;);

comparator.compare(p1, p2);             // &gt; 0
comparator.reversed().compare(p1, p2);  // &lt; 0
</code></pre><br/>
<h5>Опциональные значения</h5><br/>
Опциональные значения (optionals) не являются функциональными интерфейсами, однако являются удобным средством предотвращения NullPointerException. Это важная концепция, которая понадобится нам в следующем разделе, поэтому давайте взглянем, как работают опциональные значения.<br/>
<br/>
Опциональные значение — это по сути контейнер для значения, которое может быть равно null. Например, вам нужен метод, который возвращает какое-то значение, но иногда он должен возвращать пустое значение. Вместо того, чтобы возвращать null, в Java 8 вы можете вернуть опциональное значение.<br/>
<br/>
<pre><code class="java">Optional&lt;String&gt; optional = Optional.of(&quot;bam&quot;);

optional.isPresent();           // true
optional.get();                 // &quot;bam&quot;
optional.orElse(&quot;fallback&quot;);    // &quot;bam&quot;

optional.ifPresent((s) -&gt; System.out.println(s.charAt(0)));     // &quot;b&quot;
</code></pre><br/>
<h4>Потоки</h4><br/>
Тип <code>java.util.Stream</code> представляет собой последовательность элементов, над которой можно производить различные операции. Операции над потоками бывают или промежуточными (intermediate) или конечными (terminal). Конечные операции возвращают результат определенного типа, а промежуточные операции возвращают тот же поток. Таким образом вы можете строить цепочки из несколько операций над одним и тем же потоком. Поток создаются на основе источников, например типов, реализующих <code>java.util.Collection</code>, такие как списки или множества (ассоциативные массивы не поддерживаются). Операции над потоками могут выполняться как последовательно, так и параллельно.<br/>
<br/>
Сначала давайте посмотрим, как работать с потоком последовательно. Сперва создадим источник в виде списка строк:<br/>
<br/>
<pre><code class="java">List&lt;String&gt; stringCollection = new ArrayList&lt;&gt;();
stringCollection.add(&quot;ddd2&quot;);
stringCollection.add(&quot;aaa2&quot;);
stringCollection.add(&quot;bbb1&quot;);
stringCollection.add(&quot;aaa1&quot;);
stringCollection.add(&quot;bbb3&quot;);
stringCollection.add(&quot;ccc&quot;);
stringCollection.add(&quot;bbb2&quot;);
stringCollection.add(&quot;ddd1&quot;);
</code></pre><br/>
В Java 8 вы можете быстро создавать потоки, используя вызовы <code>Collection.stream()</code> или <code>Collection.parallelStream()</code>. Следующие разделы объясняют наиболее распространенные операции над потоками.<br/>
<br/>
<h5>Filter</h5><br/>
Операция Filter принимает предикат, который фильтрует все элементы потока. Эта операция является <i>промежуточной</i>, т.е. позволяет нам вызвать другую операцию (например, <code>forEach</code>) над результатом. ForEach принимает функцию, которая вызывается для каждого элемента в (уже отфильтрованном) поток. ForEach является <i>конечной</i> операцией. Она не возращает никакого значения, поэтому дальнейший вызов потоковых операций невозможен.<br/>
<br/>
<pre><code class="java">stringCollection
    .stream()
    .filter((s) -&gt; s.startsWith(&quot;a&quot;))
    .forEach(System.out::println);

// &quot;aaa2&quot;, &quot;aaa1&quot;
</code></pre><br/>
<h5>Sorted</h5><br/>
Операция Sorted является <i>промежуточной</i> операцией, которая возвращает отсортированное представление потока. Элементы сортируются в обычном порядке, если вы не предоставили свой компаратор:<br/>
<br/>
<pre><code class="java">stringCollection
    .stream()
    .sorted()
    .filter((s) -&gt; s.startsWith(&quot;a&quot;))
    .forEach(System.out::println);

// &quot;aaa1&quot;, &quot;aaa2&quot;
</code></pre><br/>
Помните, что <code>sorted</code> создает всего лишь отсортированное представление и не влияет на порядок элементов в исходной коллекции. Порядок строк в <code>stringCollection</code> остается нетронутым:<br/>
<br/>
<pre><code class="java">System.out.println(stringCollection);
// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1
</code></pre><br/>
<h5>Map</h5><br/>
<i>Промежуточная</i> операция <code>map</code> преобразовывает каждый элемент в другой объект при помощи переданной функции. Следующий пример преобразовывает каждую строку в строку в верхнем регистре. Однако вы так же можете использовать <code>map</code> для преобразования каждого объекта в объект другого типа. Тип результирующего потока зависит от типа функции, которую вы передаете при вызове <code>map</code>.<br/>
<br/>
<pre><code class="java">stringCollection
    .stream()
    .map(String::toUpperCase)
    .sorted((a, b) -&gt; b.compareTo(a))
    .forEach(System.out::println);

// &quot;DDD2&quot;, &quot;DDD1&quot;, &quot;CCC&quot;, &quot;BBB3&quot;, &quot;BBB2&quot;, &quot;AAA2&quot;, &quot;AAA1&quot;
</code></pre><br/>
<h5>Match</h5><br/>
Для проверки, удовлетворяет ли поток заданному предикату, используются различные операции сопоставления (match). Все операции сопоставления являются <i>конечными</i> и возвращают результат типа boolean.<br/>
<br/>
<pre><code class="java">boolean anyStartsWithA =
    stringCollection
        .stream()
        .anyMatch((s) -&gt; s.startsWith(&quot;a&quot;));

System.out.println(anyStartsWithA);      // true

boolean allStartsWithA =
    stringCollection
        .stream()
        .allMatch((s) -&gt; s.startsWith(&quot;a&quot;));

System.out.println(allStartsWithA);      // false

boolean noneStartsWithZ =
    stringCollection
        .stream()
        .noneMatch((s) -&gt; s.startsWith(&quot;z&quot;));

System.out.println(noneStartsWithZ);      // true
</code></pre><br/>
<h5>Count</h5><br/>
Операция <code>Count</code> является <i>конечной</i> операцией и возвращает количество элементов в потоке. Типом возвращаемого значения является <code>long</code>.<br/>
<br/>
<pre><code class="java">long startsWithB =
    stringCollection
        .stream()
        .filter((s) -&gt; s.startsWith(&quot;b&quot;))
        .count();

System.out.println(startsWithB);    // 3
</code></pre><br/>
<h5>Reduce</h5><br/>
Эта конечная операция производит свертку элементов потока по заданной функции. Результатом является опциональное значение.<br/>
<br/>
<pre><code class="java">Optional&lt;String&gt; reduced =
    stringCollection
        .stream()
        .sorted()
        .reduce((s1, s2) -&gt; s1 + &quot;#&quot; + s2);

reduced.ifPresent(System.out::println);
// &quot;aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2&quot;
</code></pre><br/>
<h4>Параллельные потоки</h4><br/>
Как уже упоминалось выше, потоки могут быть последовательными и параллельными. Операции над последовательными потоками выполняются в одном потоке процессора, над параллельными — используя несколько потоков процессора.<br/>
<br/>
Следующие пример демонстрирует, как можно легко увеличить скорость работы, используя параллельные потоки.<br/>
<br/>
Сперва создадим большой список из уникальных элементов:<br/>
<br/>
<pre><code class="java">int max = 1000000;
List&lt;String&gt; values = new ArrayList&lt;&gt;(max);
for (int i = 0; i &lt; max; i++) {
    UUID uuid = UUID.randomUUID();
    values.add(uuid.toString());
}
</code></pre><br/>
Теперь измерим время сортировки этого списка.<br/>
<br/>
<h6>Последовательная сортировка</h6><br/>
<pre><code class="java">long t0 = System.nanoTime();

long count = values.stream().sorted().count();
System.out.println(count);

long t1 = System.nanoTime();

long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);
System.out.println(String.format(&quot;sequential sort took: %d ms&quot;, millis));

// sequential sort took: 899 ms
</code></pre><br/>
<h6>Параллельная сортировка</h6><br/>
<pre><code class="java">long t0 = System.nanoTime();

long count = values.parallelStream().sorted().count();
System.out.println(count);

long t1 = System.nanoTime();

long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);
System.out.println(String.format(&quot;parallel sort took: %d ms&quot;, millis));

// parallel sort took: 472 ms
</code></pre><br/>
Как вы можете видеть, оба куска кода практически идентичны, однако параллельная сортировка почти в два раза быстрее. Все, что вам нужно сделать, это заменить вызов <code>stream()</code> на <code>parallelStream()</code>.<br/>
<br/>
<h4>Ассоциативные массивы</h4><br/>
Как уже упоминалось, ассоциативные массивы (maps) не поддерживают потоки. Вместо этого ассоциативные массивы теперь поддерживают различные полезные методы, которые решают часто встречаемые задачи.<br/>
<br/>
<pre><code class="java">Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();

for (int i = 0; i &lt; 10; i++) {
    map.putIfAbsent(i, &quot;val&quot; + i);
}

map.forEach((id, val) -&gt; System.out.println(val));
</code></pre><br/>
Этот код в особых комментариях не нуждается: <code>putIfAbsent</code> позволяет нам не писать дополнительные проверки на null; <code>forEach</code> принимает потребителя, который производит операцию над каждым элементом массива.<br/>
<br/>
Этот код показывает как использовать для вычислений код при помощи различных функций:<br/>
<br/>
<pre><code class="java">map.computeIfPresent(3, (num, val) -&gt; val + num);
map.get(3);             // val33

map.computeIfPresent(9, (num, val) -&gt; null);
map.containsKey(9);     // false

map.computeIfAbsent(23, num -&gt; &quot;val&quot; + num);
map.containsKey(23);    // true

map.computeIfAbsent(3, num -&gt; &quot;bam&quot;);
map.get(3);             // val33
</code></pre><br/>
Затем мы узнаем, как удалить объект по ключу, только если этот объект ассоциирован с ключом:<br/>
<br/>
<pre><code class="java">map.remove(3, &quot;val3&quot;);
map.get(3);             // val33

map.remove(3, &quot;val33&quot;);
map.get(3);             // null
</code></pre><br/>
Еще один полезный метод:<br/>
<br/>
<pre><code class="java">map.getOrDefault(42, &quot;not found&quot;);  // not found
</code></pre><br/>
Объединить записи двух массивов? Легко:<br/>
<br/>
<pre><code class="java">map.merge(9, &quot;val9&quot;, (value, newValue) -&gt; value.concat(newValue));
map.get(9);             // val9

map.merge(9, &quot;concat&quot;, (value, newValue) -&gt; value.concat(newValue));
map.get(9);             // val9concat
</code></pre><br/>
В случае отсутствия ключа <code>Merge</code> создает новую пару ключ-значение. В противном случае — вызывает функцию объединения для существующего значения.<br/>
<br/>
<h4>API для работы с датами</h4><br/>
Java 8 содержит совершенно новый API для работы с датами и временем, расположенный в пакете <code>java.time</code>. Новый API сравним с библиотекой <a href="http://www.joda.org/joda-time/">Joda-Time</a>, однако <a href="http://blog.joda.org/2009/11/why-jsr-310-isn-joda-time_4941.html">имеются отличия</a>. Следующие разделы рассказывают о наиболее важных частях нового API.<br/>
<br/>
<h5>Clock</h5><br/>
Тип <code>Clock</code> предоставляет доступ к текущей дате и времени. Этот тип знает о часовых поясах и может использоваться вместо вызова <code>System.currentTimeMillis()</code> для возвращения миллисекунд. Такая точная дата также может быть представлена классом <code>Instant</code>. Объекты этого класса могут быть использованы для создания объектов устаревшего типа<br/>
<code>java.util.Date</code>.<br/>
<br/>
<pre><code class="java">Clock clock = Clock.systemDefaultZone();
long millis = clock.millis();

Instant instant = clock.instant();
Date legacyDate = Date.from(instant);   // legacy java.util.Date
</code></pre><br/>
<h5>Часовые пояса</h5><br/>
Часовые пояса представлены типом <code>ZoneId</code>. Доступ к ним можно получить при помощи статических фабричных методов. Часовые пояса содержат смещения, которые важны для конвертации дат и времени в местные.<br/>
<br/>
<pre><code class="java">System.out.println(ZoneId.getAvailableZoneIds());
// prints all available timezone ids

ZoneId zone1 = ZoneId.of(&quot;Europe/Berlin&quot;);
ZoneId zone2 = ZoneId.of(&quot;Brazil/East&quot;);
System.out.println(zone1.getRules());
System.out.println(zone2.getRules());

// ZoneRules[currentStandardOffset=+01:00]
// ZoneRules[currentStandardOffset=-03:00]
</code></pre><br/>
<h5>LocalTime</h5><br/>
Тип <code>LocalTime</code> представляет собой время с учетом часового пояса, например, 10pm или 17:30:15. В следующем примере создаются два местных времени для часовых поясов, определенных выше. Затем оба времени сравниваются, и вычисляется разница между ними в часах и минутах.<br/>
<br/>
<pre><code class="java">LocalTime now1 = LocalTime.now(zone1);
LocalTime now2 = LocalTime.now(zone2);

System.out.println(now1.isBefore(now2));  // false

long hoursBetween = ChronoUnit.HOURS.between(now1, now2);
long minutesBetween = ChronoUnit.MINUTES.between(now1, now2);

System.out.println(hoursBetween);       // -3
System.out.println(minutesBetween);     // -239
</code></pre><br/>
Тип LocalTime содержит различные фабричные методы, которые упрощают создание новых экземпляров, а также парсинг строк.<br/>
<br/>
<pre><code class="java">LocalTime late = LocalTime.of(23, 59, 59);
System.out.println(late);       // 23:59:59

DateTimeFormatter germanFormatter =
    DateTimeFormatter
        .ofLocalizedTime(FormatStyle.SHORT)
        .withLocale(Locale.GERMAN);

LocalTime leetTime = LocalTime.parse(&quot;13:37&quot;, germanFormatter);
System.out.println(leetTime);   // 13:37
</code></pre><br/>
<h5>LocalDate</h5><br/>
Тип <code>LocalDate</code> представляет конкретную дату, например, 2014-03-11. Объекты <code>LocalDate</code> неизменяемы и являются аналогом <code>LocalTime</code>. Пример демонстрирует вычисление новой даты путем сложения или вычитания дней, месяцев или годов. Помните, что каждая операция возвращает новый экземпляр.<br/>
<br/>
<pre><code class="java">LocalDate today = LocalDate.now();
LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);
LocalDate yesterday = tomorrow.minusDays(2);

LocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4);
DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();
System.out.println(dayOfWeek);    // FRIDAY
</code></pre><br/>
Создание экземпляра <code>LocalDate</code> путем парсинга строки:<br/>
<br/>
<pre><code class="java">DateTimeFormatter germanFormatter =
    DateTimeFormatter
        .ofLocalizedDate(FormatStyle.MEDIUM)
        .withLocale(Locale.GERMAN);

LocalDate xmas = LocalDate.parse(&quot;24.12.2014&quot;, germanFormatter);
System.out.println(xmas);   // 2014-12-24
</code></pre><br/>
<h5>LocalDateTime</h5><br/>
Тип <code>LocalDateTime</code> представляет собой комбинацию даты и времени. Объекты <code>LocalDateTime</code> неизменяемы и работают аналогично <code>LocalTime</code> и <code>LocalDate</code>. Мы можем использовать различные методы для извлечения конкретных значений из даты-времени:<br/>
<br/>
<pre><code class="java">LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);

DayOfWeek dayOfWeek = sylvester.getDayOfWeek();
System.out.println(dayOfWeek);      // WEDNESDAY

Month month = sylvester.getMonth();
System.out.println(month);          // DECEMBER

long minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);
System.out.println(minuteOfDay);    // 1439
</code></pre><br/>
Путем добавления информации о часовом поясе мы можем получить <code>Instant</code>.<br/>
<br/>
<pre><code class="java">Instant instant = sylvester
        .atZone(ZoneId.systemDefault())
        .toInstant();

Date legacyDate = Date.from(instant);
System.out.println(legacyDate);     // Wed Dec 31 23:59:59 CET 2014
</code></pre><br/>
Форматирование даты-времени работает так же, как и форматирование даты или времени. Мы можем использовать библиотечные или свои собственные шаблоны.<br/>
<br/>
<pre><code class="java">DateTimeFormatter formatter =
    DateTimeFormatter
        .ofPattern(&quot;MMM dd, yyyy - HH:mm&quot;);

LocalDateTime parsed = LocalDateTime.parse(&quot;Nov 03, 2014 - 07:13&quot;, formatter);
String string = formatter.format(parsed);
System.out.println(string);     // Nov 03, 2014 - 07:13
</code></pre><br/>
В отличии от <code>java.text.NumberFormat</code>, новый <code>DateTimeFormatter</code> является неизменяемым и потокобезопасным.<br/>
<br/>
Подробно о синтаксисе шаблонов можно почитать <a href="http://download.java.net/jdk8/docs/api/java/time/format/DateTimeFormatter.html">здесь</a>.<br/>
<br/>
<h4>Аннотации</h4><br/>
Аннотации в Java 8 являются повторяемыми. Давайте сразу посмотрим пример, чтобы понять, что это такое.<br/>
<br/>
Сперва мы определим аннотацию-обертку, которая содержит массив аннотаций:<br/>
<br/>
<pre><code class="java">@interface Hints {
    Hint[] value();
}

@Repeatable(Hints.class)
@interface Hint {
    String value();
}
</code></pre><br/>
Java 8 позволяет нам использовать множество аннотаций одного типа путем указания аннотации <code>@Repeatable</code>.<br/>
<br/>
Вариант 1: использовать аннотацию-контейнер (старый способ)<br/>
<pre><code class="java">@Hints({@Hint(&quot;hint1&quot;), @Hint(&quot;hint2&quot;)})
class Person {}
</code></pre><br/>
Вариант 2: использовать повторяемую аннотацию (новый способ)<br/>
<pre><code class="java">@Hint(&quot;hint1&quot;)
@Hint(&quot;hint2&quot;)
class Person {}
</code></pre><br/>
При использовании варианта 2 компилятор автоматически подставляет аннотацию <code>@Hints</code>. Это важно при чтении информации об аннотациях через рефлексию.<br/>
<br/>
<pre><code class="java">Hint hint = Person.class.getAnnotation(Hint.class);
System.out.println(hint);                   // null

Hints hints1 = Person.class.getAnnotation(Hints.class);
System.out.println(hints1.value().length);  // 2

Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class);
System.out.println(hints2.length);          // 2
</code></pre><br/>
Хотя мы никогда не объявляли аннотацию  @Hints в классе <code>Person</code>, она доступна нам при вызове <code>getAnnotation(Hints.class)</code>. Однако более удобным является метод <code>getAnnotationsByType</code>, который напрямую предоставляет доступ ко всем аннотациям <code>@Hint</code>.<br/>
<br/>
Более того, аннотации в Java 8 можно использовать еще на двух элементах:<br/>
<br/>
<pre><code class="java">@Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})
@interface MyAnnotation {}
</code></pre><br/>
<h4>Вот и все</h4><br/>
На этом введение в программирование на Java 8 завершено. Вам остается самостоятельно изучить другие новинки JDK 1.8, например, <code>Arrays.parallelSort</code>, <code>StampedLock</code>, <code>CompletableFuture</code> и другие.<br/>
<br/>



Третья статья

Название: Первые шаги с Java 9 и проект Jigsaw – часть первая

Еще со времен книги &quot;<a href="http://www.piter.com/collection/kompyutery-i-internet/product/java-novoe-pokolenie-razrabotki">Java. Новое поколение разработки</a>&quot; мы следим за развитием давно анонсированных новых возможностей этого языка, объединенных под общим названием &quot;<a href="http://openjdk.java.net/projects/jigsaw/">Project Jigsaw</a>&quot;. Сегодня предлагаем перевод статьи от 24 ноября, вселяющей достаточную уверенность, что в версии Java 9 Jigsaw все-таки состоится. <br/>
<a name="habracut"></a><br/>
Прошло восемь лет после зарождения проекта Jigsaw, задача которого заключается в модуляризации платформы Java и сводится к внедрению общей системы модулей. <b>Предполагается, что Jigsaw впервые появится в версии Java 9</b>. Этот релиз ранее планировался и к выходу Java 7, и к Java 8. Область применения Jigsaw также неоднократно менялась. Теперь есть все основания полагать, что Jigsaw практически готов, поскольку ему было уделено большое внимание в пленарном докладе Oracle на конференции JavaOne 2015, а также <a href="http://openjdk.java.net/projects/jigsaw/j1/">сразу несколько выступлений</a> на эту тему. Что это означает для вас? Что такое проект Jigsaw и как с ним работать? <br/>
<br/>
Это первая из двух публикаций, в которых я хочу сделать краткое введение в систему модулей и на многочисленных примерах кода продемонстрировать поведение Jigsaw. В первой части мы обсудим, что представляет собой система модулей, как был модуляризован JDK, а также рассмотрим поведение компилятора и исполняющей среды в определенных ситуациях.<br/>
<br/>
Что такое модуль?<br/>
<br/>
Описать модуль просто: это единица в составе программы, причем каждый модуль сразу содержит ответы на три вопроса. Эти ответы записаны в файле <code>module-info.java<br/>
</code>, который есть у каждого модуля.<br/>
<br/>
<ul>
<li>Как называется модуль?</li>
<li>Что он экспортирует?</li>
<li>Что для этого требуется?</li>
</ul><br/>
 <br/>
<img src="https://habrastorage.org/files/d0a/f9a/564/d0af9a5640a948b89b4a93f8ab0abf4c.png"/><br/>
<br/>
<i>Простой модуль</i><br/>
<br/>
Ответ на первый вопрос несложен. (Почти) у каждого модуля есть имя. Оно должно соответствовать соглашениям об именовании пакетов, например, <code>de.codecentric.mymodule<br/>
</code>, во избежание конфликтов.<br/>
<br/>
Для ответа на второй вопрос в модуле предоставляется список всех <b>пакетов</b> данного конкретного модуля, которые считаются публичными API и, следовательно, могут использоваться другими модулями. Если класс не является экспортированным пакетом, никто не может получить к нему доступ извне вашего модуля — даже если он публичный. <br/>
<br/>
Ответ на третий вопрос — это список тех <b>модулей</b>, от которых зависит данный модуль. Все публичные типы, <b>экспортируемые</b> данными модулями, доступны зависимому модулю. Команда Jigsaw старается ввести в обиход термин «<b>считывать</b>» другой модуль.<br/>
<br/>
Это серьезное изменение статус-кво. Вплоть до Java 8 включительно любой публичный тип в пути к вашим классам был доступен любому другому типу. С приходом Jigsaw система доступности типов Java изменяется с<br/>
<br/>
<ul>
<li>public</li>
<li>private</li>
<li>default</li>
<li>protected</li>
</ul><br/>
<br/>
на<br/>
<br/>
<ul>
<li>публичный для всех, кто читает этот модуль (exports)</li>
<li>публичный для некоторых модулей, читающих этот (exports to, об этом пойдет речь во второй части)</li>
<li>публичный для любого другого класса в рамках данного модуля </li>
<li>private</li>
<li>default</li>
<li>protected</li>
</ul><br/>
<br/>
<b>Модуляризованный JDK</b><br/>
<br/>
Зависимости модулей должны образовывать ациклический граф, не допуская, таким образом, циклических зависимостей. Чтобы реализовать такой принцип, команде Jigsaw предстояло решить следующую большую задачу: разбить на модули исполняющую среду Java, которая, как сообщалось, полна циклических и нелогичных зависимостей. Получился такой <a href="https://bugs.openjdk.java.net/secure/attachment/21573/jdk-tr.png">граф</a>: <br/>
 <br/>
<img src="https://habrastorage.org/files/fa8/6a1/07c/fa86a107c3f3457da6f81c79a4f2ac5d.png"/><br/>
<br/>
В основании графа находится java.base. Это единственный модуль, у которого есть только входящие ребра. Каждый создаваемый вами модуль <b>считывает</b> <code>java.base<br/>
</code> независимо от того, объявляете вы это или нет – как и в случае подразумеваемого расширения <code>java.lang.Object<br/>
</code>. <code>java.base<br/>
</code> экспортирует такие пакеты как <code>java.lang<br/>
</code>,<code> java.util<br/>
</code>, <code>java.math<br/>
</code> и т.д.<br/>
<br/>
Модуляризация JDK означает, что теперь вы можете указывать, какие модули исполняющей среды Java, которые хотите использовать. Так, ваше приложение не должно задействовать среду, поддерживающую Swing или Corba, если вы не читаете модулей<code> java.desktop<br/>
</code> или<code> java.corba<br/>
</code>. Создание такой урезанной среды будет описано во второй части. <br/>
Но довольно сухой теории…<br/>
<br/>
<b>Похимичим</b><br/>
<br/>
Весь код, приведенный в статье, доступен <a href="https://github.com/ftrossbach/IntroToJigsaw">здесь</a>, включая сценарии оболочки для компиляции, упаковки и запуска примера.<br/>
<br/>
Рассматриваемый здесь практический случай очень прост. У меня есть модуль <code>de.codecentric.zipvalidator<br/>
</code>, выполняющий определенную валидацию zip-кода. Этот модуль считывается модулем <code>de.codecentric.addresschecker<br/>
</code> (который мог бы проверять отнюдь не только zip-коды, но здесь мы этого не делаем, чтобы не усложнять).<br/>
Zip-валидатор описан в следующем файле <code>module-info.java<br/>
</code>:<br/>
<br/>
module de.codecentric.zipvalidator{<br/>
 exports de.codecentric.zipvalidator.api; <br/>
}<br/>
<br/>
Итак, этот модуль экспортирует пакет <code>de.codecentric.zipvalidator.api<br/>
</code> и не читает никаких других модулей (кроме<code> java.base<br/>
</code>). Этот модуль считывается addresschecker’ом:<br/>
<br/>
<pre><code class="java">module de.codecentric.addresschecker{
    exports de.codecentric.addresschecker.api;
    requires de.codecentric.zipvalidator;
}
</code></pre><br/>
<br/>
Общая структура файловой системы такова:<br/>
<br/>
<pre><code class="java">two-modules-ok/
├── de.codecentric.addresschecker
│   ├── de
│   │   └── codecentric
│   │       └── addresschecker
│   │           ├── api
│   │           │   ├── AddressChecker.java
│   │           │   └── Run.java
│   │           └── internal
│   │               └── AddressCheckerImpl.java
│   └── module-info.java
├── de.codecentric.zipvalidator
│   ├── de
│   │   └── codecentric
│   │       └── zipvalidator
│   │           ├── api
│   │           │   ├── ZipCodeValidator.java
│   │           │   └── ZipCodeValidatorFactory.java
│   │           ├── internal
│   │           │   └── ZipCodeValidatorImpl.java
│   │           └── model
│   └── module-info.java
</code></pre><br/>
<br/>
Действует соглашение, согласно которому модуль помещается в каталоге, одноименном этому модулю.<br/>
В первом примере все выглядит отлично: мы работаем строго по правилам и в нашем классе <code>AddressCheckerImpl <br/>
</code> обращаемся только к <code>ZipCodeValidator<br/>
</code> и <code>ZipCodeValidatorFactory<br/>
</code> из экспортированного пакета:<br/>
<br/>
<pre><code class="java">public class AddressCheckerImpl implements AddressChecker {
    @Override
    public boolean checkZipCode(String zipCode) {
        return ZipCodeValidatorFactory.getInstance().zipCodeIsValid(zipCode);
    }
}
</code></pre><br/>
<br/>
Теперь запустим <code>javac<br/>
</code> и сгенерируем байт-код. Чтобы скомпилировать <code>zipvalidator<br/>
</code> (что нам, разумеется, нужно сделать в первую очередь, так как addresschecker считывает zipvalidator), мы делаем<br/>
<br/>
<pre><code class="java">javac -d de.codecentric.zipvalidator \
$(find de.codecentric.zipvalidator -name &quot;*.java&quot;)
</code></pre><br/>
<br/>
Выглядит знакомо – пока нет речи о модулях, поскольку zipvalidator не зависит ни от одного пользовательского модуля. Команда <code>find<br/>
</code> просто помогает нам составить список файлов <code>.java<br/>
</code> в указанном каталоге.<br/>
Но как мы сообщим <code>javac<br/>
</code> о структуре наших модулей, когда дойдем до компиляции? Для этого в Jigsaw вводится переключатель -<code>modulepath<br/>
</code> или <code>-mp<br/>
</code>.<br/>
<br/>
Чтобы скомпилировать addresschecker, мы используем следующую команду:<br/>
<br/>
javac -modulepath. -d de.codecentric.addresschecker \<br/>
$(find de.codecentric.addresschecker -name &quot;*.java&quot;)<br/>
<br/>
При помощи modulepath мы сообщаем javac, где найти скомпилированные модули (в данном случае, это .), получается нечто похожее на переключатель пути к классам (classpath switch).<br/>
<br/>
Однако компиляция множества модулей по отдельности кажется какой-то морокой – лучше воспользоваться другим переключателем -modulesourcepath, чтобы скомпилировать сразу несколько модулей:<br/>
<br/>
<pre><code class="java">javac -d . -modulesourcepath . $(find . -name &quot;*.java&quot;)
</code></pre><br/>
<br/>
Этот код ищет среди всех подкаталогов. каталоги модулей и компилирует все содержащиеся в них java-файлы.<br/>
Все скомпилировав, мы, естественно, хотим попробовать, что получилось:<br/>
<br/>
<pre><code class="java">java -mp . -m de.codecentric.addresschecker/de.codecentric.addresschecker.api.Run 76185
</code></pre><br/>
<br/>
Опять же, мы указываем путь к модулям, сообщая JVM, где находятся скомпилированные модули. Также задаем основной класс (и параметр).<br/>
<br/>
Ура, вот и вывод:<br/>
<br/>
<pre><code class="java">76185 is a valid zip code
</code></pre><br/>
<br/>
<b>Модульные Jar</b><br/>
<br/>
Как известно, в мире Java мы привыкли получать и отправлять наш байт-код в jar-файлах. В Jigsaw вводится концепция модульного jar.<b>Модульный jar</b> очень похож на обычный, но в нем также содержится скомпилированный <code>module-info.class.<br/>
</code> При условии, что такие файлы скомпилированы для нужной целевой версии, эти архивы будут обратно совместимы. <code>module-info.java<br/>
</code> – не действительное имя типа, поэтому скомпилированный <code>module-info.class<br/>
</code> будет игнорироваться более старыми JVM.<br/>
<br/>
Чтобы собрать jar для zipvalidator, пишем:<br/>
<br/>
<pre><code class="java">jar --create --file bin/zipvalidator.jar \
--module-version=1.0 -C de.codecentric.zipvalidator
</code></pre>.<br/>
<br/>
Указываем файл вывода, версию (хотя отдельно не оговаривается использование нескольких версий модуля в Jigsaw во время исполнения) и модуль, который следует упаковать. <br/>
Поскольку у addresschecker также есть основной класс, мы можем указать и его:<br/>
<br/>
<pre><code class="java">jar --create --file=bin/addresschecker.jar --module-version=1.0 \
--main-class=de.codecentric.addresschecker.api.Run \
-C de.codecentric.addresschecker .
</code></pre><br/>
<br/>
Основной класс не указывается в <code>module-info.java<br/>
</code>, как можно было бы ожидать (изначально команда Jigsaw так и планировала поступить), а обычно записывается в манифесте. <br/>
<br/>
Если запустить этот пример с<br/>
<br/>
<pre><code class="java">java -mp bin -m de.codecentric.addresschecker 76185
</code></pre><br/>
<br/>
получим такой же ответ, как и в предыдущем случае. Мы вновь указываем путь к модулям, который в данном случае ведет к каталогу bin, куда мы записали наши jars. Нам не приходится указывать основной класс, так как в манифесте addresschecker.jar уже есть эта информация. Достаточно сообщить имя модуля переключателю <code>-m<br/>
</code>.<br/>
<br/>
До сих пор все было легко и приятно. Далее давайте немного повозимся с модулями и посмотрим, как Jigsaw ведет себя во время компиляции и исполнения, если вы начинаете хулиганить. <br/>
<br/>
<b>Использование неэкспортированных типов</b><br/>
<br/>
В этом примере посмотрим, что происходит, если мы обращаемся к такому типу из другого модуля, который не должны использовать.<br/>
<br/>
Поскольку мы устали от этой фабричной штуки в <code>AddressCheckerImpl<br/>
</code>, меняем реализацию на<br/>
<br/>
<pre><code class="java">return new ZipCodeValidatorImpl().zipCodeIsValid(zipCode);
</code></pre><br/>
<br/>
При попытке скомпилировать получаем ожидаемое<br/>
<br/>
<pre><code class="java">error: ZipCodeValidatorImpl is not visible because
package de.codecentric.zipvalidator.internal is not visible
</code></pre><br/>
Итак, именно использование неэкспортированных типов во время компиляции не срабатывает.<br/>
Но мы-то умные ребята, поэтому немного схитрим и используем рефлексию.<br/>
<br/>
<pre><code class="java">ClassLoader classLoader = AddressCheckerImpl.class.getClassLoader();
try {
    Class aClass = classLoader.loadClass(&quot;de.[..].internal.ZipCodeValidatorImpl&quot;);
    return ((ZipCodeValidator)aClass.newInstance()).zipCodeIsValid(zipCode);
} catch (Exception e) {
    throw new  RuntimeException(e);
}
</code></pre><br/>
Скомпилировалось отлично, давайте запускать. Ан нет, не так-то просто одурачить Jigsaw:<br/>
<br/>
<pre><code class="java">java.lang.IllegalAccessException:
class de.codecentric.addresschecker.internal.AddressCheckerImpl
(in module de.codecentric.addresschecker) cannot access class [..].internal.ZipCodeValidatorImpl
(in module de.codecentric.zipvalidator) because module
de.codecentric.zipvalidator does not export package
de.codecentric.zipvalidator.internal to module
de.codecentric.addresschecker
</code></pre><br/>
<br/>
Итак, Jigsaw включает проверку не только во время компиляции, но и во время выполнения! Причем предельно четко сообщает нам, что мы сделали неправильно.<br/>
<br/>
<b>Циклические зависимости</b><br/>
<br/>
В следующем случае мы вдруг осознали, что в API модуля addresschecker содержится класс, которым вполне мог бы воспользоваться zipvalidator. Поскольку мы ленивы, вместо рефакторинга класса в другой модуль мы объявляем зависимость для addresschecker:<br/>
<br/>
<pre><code class="java">module de.codecentric.zipvalidator{
        requires de.codecentric.addresschecker;
        exports de.codecentric.zipvalidator.api;

}
</code></pre><br/>
<br/>
Поскольку циклические зависимости запрещены по определению, на нашем пути (ради общего блага) встает компилятор: <br/>
<br/>
<pre><code class="java">./de.codecentric.zipvalidator/module-info.java:2:
error: cyclic dependence involving de.codecentric.addresschecker
</code></pre><br/>
<br/>
Так делать нельзя, и нас заранее об этом предупреждают, еще во время компиляции.<br/>
<br/>
<b>Подразумеваемая считываемость</b><br/>
<br/>
Чтобы расширить функционал, мы решаем унаследовать zipvalidator, введя новый модуль <code>de.codecentric.zipvalidator.model<br/>
</code>, содержащий определенную <b>модель</b> результата валидации, а не просто банальный булеан. Новая структура файла показана здесь:<br/>
<br/>
<pre><code class="java">three-modules-ok/
├── de.codecentric.addresschecker
│   ├── de
│   │   └── codecentric
│   │       └── addresschecker
│   │           ├── api
│   │           │   ├── AddressChecker.java
│   │           │   └── Run.java
│   │           └── internal
│   │               └── AddressCheckerImpl.java
│   └── module-info.java
├── de.codecentric.zipvalidator
│   ├── de
│   │   └── codecentric
│   │       └── zipvalidator
│   │           ├── api
│   │           │   ├── ZipCodeValidator.java
│   │           │   └── ZipCodeValidatorFactory.java
│   │           └── internal
│   │               └── ZipCodeValidatorImpl.java
│   └── module-info.java
├── de.codecentric.zipvalidator.model
│   ├── de
│   │   └── codecentric
│   │       └── zipvalidator
│   │           └── model
│   │               └── api
│   │                   └── ZipCodeValidationResult.java
│   └── module-info.java
</code></pre><br/>
<br/>
Класс <code>ZipCodeValidationResult<br/>
</code> – простое перечисление, имеющее экземпляры вида “too short”, “too long” и т.д.<br/>
Класс <code>module-info.java<br/>
</code> наследуется таким образом: <br/>
<br/>
<pre><code class="java">module de.codecentric.zipvalidator{
       exports de.codecentric.zipvalidator.api;
       requires de.codecentric.zipvalidator.model;
}
</code></pre><br/>
<br/>
Теперь наша реализация ZipCodeValidator выглядит так:<br/>
<br/>
<pre><code class="java">@Override
public &lt;strong&gt;ZipCodeValidationResult&lt;/strong&gt; zipCodeIsValid(String zipCode) {
   if (zipCode == null) {
       return ZipCodeValidationResult.ZIP_CODE_NULL;
[snip]
   } else {
       return ZipCodeValidationResult.OK;
   }
}
</code></pre><br/>
<br/>
Модуль addresschecker теперь адаптирован так, что может принимать в качестве возвращаемого типа и перечисление, так что можно приступать, верно? Нет! Компиляция дает:<br/>
<br/>
<pre><code class="java">./de.codecentric.addresschecker/de/[..]/internal/AddressCheckerImpl.java:5:
error: ZipCodeValidationResult is not visible because package
de.codecentric.zipvalidator.model.api is not visible

</code></pre><br/>
Произошла ошибка при компиляции addresschecker – zipvalidator использует экспортированные типы из модели zipvalidator model в своем публичном API. Поскольку addresschecker не читает этот модуль, он не может обратиться к этому типу.<br/>
<br/>
Существует два решения такой проблемы. Очевидное: добавить ребро чтения из addresschecker к модели zipvalidator. Однако это скользкая дорожка: зачем нам объявлять эту зависимость, если она нужна только для работы с zipvalidator? Разве zipvalidator не должен гарантировать, что мы сможем получить доступ ко всем необходимым модулям? Должен и может – здесь мы подходим к подразумеваемой читаемости. Добавив ключевое слово public к требуемому определению, мы сообщаем всем клиентским модулям, что они также должны считывать другой модуль. В качестве примера рассмотрим обновленный класс <code>module-info.java<br/>
</code> zipvalidator’а:<br/>
<br/>
<pre><code class="java">module de.codecentric.zipvalidator{
       exports de.codecentric.zipvalidator.api;
       requires public de.codecentric.zipvalidator.model;
}
</code></pre><br/>
<br/>
Ключевое слово <code>public<br/>
</code> сообщает всем модулям, читающим zipvalidator, что они также должны читать его модель. Работать с путем к классам приходилось иначе: так, вы не могли положиться на Maven POM, если требовалось гарантировать, чтобы все ваши зависимости также были доступны любому клиенту; чтобы добиться этого, приходилось явно указывать их, если они входили в состав вашего публичного API. Это очень красивая модель: если вы используете зависимости только внутри класса, то какое дело до них вашим клиентам? А если используете их вне класса, то также должны прямо об этом сообщить. <br/>
<br/>
<b>Резюме</b><br/>
<br/>
Вот и подошла к концу первая часть. Мы обсудили три вопроса, на которые нужно ответить для каждого модуля, а также о модуляризации исполняющей среды Java. Далее мы рассмотрели пример, где скомпилировали, запустили и упаковали простое приложение на Java, состоящее из двух модулей. Затем на рабочем примере изучили, как система модулей реагирует на нарушение установленных правил. Далее, расширив функционал, мы изучили третий модуль и поговорили о концепции подразумеваемой читаемости. <br/>
<br/>
В следующей части будут рассмотрены следующие вопросы:<br/>
<br/>
<ul>
<li>Как действует Jigsaw, если путь к модулям содержит несколько одноименных модулей? </li>
<li>Что происходит, если в пути к модулям есть разноименные модули, которые, однако, экспортируют одни и те же пакеты? </li>
<li>Что делать с унаследованными зависимостями, которые не модуляризованы? </li>
<li>Как создать собственный урезанный вариант исполняющей среды?</li>
</ul></div>




Статья четвертая

Первые шаги с Java 9 и проект Jigsaw – часть вторая

<br/>
После некоторого промедления публикуем вторую часть статьи о проекте Jigsaw и Java 9, вышедшую в блоге Codecentric. Перевод первой части находится <a href="http://habrahabr.ru/company/piter/blog/271941/">здесь</a>.<br/>
<a name="habracut"></a><br/>
<br/>
Это вторая часть статьи для тех, кто хочет поближе познакомиться с проектом Jigsaw. В <a href="http://habrahabr.ru/company/piter/blog/271941/">первой части</a> мы кратко обсудили, что такое модуль, и как была модуляризована исполняющая среда Java Runtime. Затем мы рассмотрели простой пример компиляции, упаковки и запуска модульного приложения. <br/>
<br/>
Здесь мы постараемся ответить на следующие вопросы:<br/>
<br/>
<ul>
<li>Можно ли ввести ограничение на то, какие модули смогут читать экспортированный пакет? </li>
<li>Что делать с различными версиями одного и того же модуля, присутствующими в пути к модулям?</li>
<li>Как Jigsaw взаимодействует с немодульным унаследованным кодом?</li>
<li>Как собрать собственный образ исполняющей среды Java?</li>
</ul><br/>
<br/>
Возьмем за основу пример из части 1 и продолжим работать с ним. Код по-прежнему находится здесь.<br/>
<br/>
<b>Предоставление права на чтение конкретным модулям</b><br/>
<br/>
В <a href="http://habrahabr.ru/company/piter/blog/271941/">первой части</a> мы говорили о том, как развивается доступность Java в рамках Jigsaw. Один из уровней доступности, который был упомянут, но не разъяснен как следует, таков: “публичный для некоторых модулей, тех, что читают этот модуль”. Так мы можем ограничить круг модулей, которым будет разрешено читать наши экспортированные пакеты. Допустим, разработчики <code>de.codecentric.zipvalidator<br/>
</code> терпеть не могут разработчиков <code>de.codecentric.nastymodule<br/>
</code>, поэтому могут изменить свой <code>module-info.java<br/>
</code> вот так:<br/>
<br/>
<pre><code class="java">module de.codecentric.zipvalidator{

    exports de.codecentric.zipvalidator.api
        to de.codecentric.addresschecker;
}
</code></pre><br/>
<br/>
Таким образом, лишь <code>addresschecker <br/>
</code> может получить доступ к API<code> zipvalidator<br/>
</code>. Данное указание выполняется на уровне пакетов, поэтому ничто вам не мешает ограничить доступ для одних пакетов, в то же время предоставив полный доступ для других. Такая практика именуется «<b>квалифицированный экспорт</b>». Если модуль<code> de.codecentric.nastymodule<br/>
</code> попытается обратиться к любому типу из <code>de.codecentric.zipvalidator.api<br/>
</code>, то возникнет ошибка компиляции:<br/>
<pre><code class="java">
./de.cc.nastymodule/de/cc/nastymodule/internal/AddressCheckerImpl.java:4:
error: ZipCodeValidatorFactory is not visible
       because package de.cc.zipvalidator.api is not visible
</code></pre><br/>
<br/>
Обратите внимание: программа не ругается на <code>module-info.java<br/>
</code>, так как <code>zipvalidator<br/>
</code> в принципе мог бы экспортировать видимые пакеты в <code>nastymodule<br/>
</code>. Например, квалифицированный экспорт можно применить, когда вы хотите модуляризовать внутреннюю структуру вашего приложения, но не хотите делиться экспортируемыми пакетами внутренних модулей с клиентами.<br/>
<br/>
<b>Конфликты между версиями модулей</b><br/>
<br/>
Часто случается так, что через транзитивные зависимости в одно и то же приложение попадают различные версии библиотеки — то есть, один и тот же модуль может дважды фигурировать в пути к модулям. Сразу приходят на ум два сценария:<br/>
<br/>
<ul>
<li>Модули доступны во время компиляции в различных каталогах или модульных jar, но имя у них все равно одинаковое </li>
<li>Различные версии одного и того же модуля являются разноименными </li>
</ul><br/>
<br/>
Давайте попробуем скомпилировать приложение по первому сценарию. Скопировали <code>zipvalidator<br/>
</code>:<br/>
<pre><code class="java">
two-modules-multiple-versions
├── de.codecentric.addresschecker
│   ├── de
│   │   └── codecentric
│   │       └── addresschecker
│   │           ├── api
│   │           │   ├── AddressChecker.java
│   │           │   └── Run.java
│   │           └── internal
│   │               └── AddressCheckerImpl.java
│   └── module-info.java
├── de.codecentric.zipvalidator.v1
│   ├── de
│   │   └── codecentric
│   │       └── zipvalidator
│   │           ├── api
│   │           │   ├── ZipCodeValidator.java
│   │           │   └── ZipCodeValidatorFactory.java
│   │           ├── internal
│   │           │   └── ZipCodeValidatorImpl.java
│   │           └── model
│   └── module-info.java
├── de.codecentric.zipvalidator.v2
│   ├── de
│   │   └── codecentric
│   │       └── zipvalidator
│   │           ├── api
│   │           │   ├── ZipCodeValidator.java
│   │           │   └── ZipCodeValidatorFactory.java
│   │           ├── internal
│   │           │   └── ZipCodeValidatorImpl.java
│   │           └── model
│   └── module-info.java
</code></pre><br/>
<br/>
Дублирующиеся модули находятся в разных каталогах, но имя модуля остается неизменным. Как Jigsaw реагирует на это во время компиляции?<br/>
<br/>
<pre><code class="java">./de.codecentric.zipvalidator.v2/module-info.java:1:
error: duplicate module: de.codecentric.zipvalidator
</code></pre><br/>
<br/>
Итак, здесь нам легко не отделаться. Jigsaw выдает ошибку компиляции, когда в пути к модулям присутствуют два одноименных модуля. <br/>
<br/>
Что насчет второго случая? Структура каталогов остается прежней, но теперь оба zipvalidator’а получают разные имена (<code>de.codecentric.zipvalidator.v{1|2}<br/>
</code>), и addresschecker читает оба этих имени.<br/>
<br/>
<pre><code class="java">module de.codecentric.addresschecker{
     exports de.codecentric.addresschecker.api;
     requires de.codecentric.zipvalidator.v1;
     requires de.codecentric.zipvalidator.v2;
}
</code></pre><br/>
<br/>
Скорее всего, и здесь не скомпилируется? Читать два модуля, экспортирующих одни и те же пакеты? Оказывается, скомпилируется. Я сам удивился: компилятор распознает возникшую ситуацию, но ограничивается лишь такими предупреждениями:<br/>
<br/>
<pre><code class="java">./de.cc.zipvalidator.v1/de/codecentric/zipvalidator/api/ZipCodeValidator.java:1:
warning: package exists in another module: de.codecentric.zipvalidator.v2
</code></pre><br/>
<br/>
Разработчик с готовностью проигнорирует такое предупреждение и запустит приложение. Но Jigsaw явно не нравится то, что он увидит во время выполнения:<br/>
<br/>
<pre><code class="java">java.lang.module.ResolutionException:
Modules de.codecentric.zipvalidator.v2 and de.codecentric.zipvalidator.v1 export
package de.codecentric.zipvalidator.api to module de.codecentric.addresschecker
</code></pre><br/>
<br/>
Мне это кажется малопонятным, по-моему, ошибку времени компиляции можно было бы оформить и поаккуратнее. Я поинтересовался в <a href="http://mail.openjdk.java.net/pipermail/jigsaw-dev/2015-November/005244.html">рассылке</a>, почему был выбран именно такой вариант, но на момент написания статьи ответа еще не получил. <br/>
<br/>
<b>Автоматические модули и безымянный модуль </b><br/>
<br/>
До сих пор мы работали в полностью модуляризованной среде. Но что делать в таких весьма вероятных случаях, когда придется иметь дело с немодульными Jar-файлами? Здесь вступают в игру<b> автоматические модули</b> и <b>безымянный модуль</b>.<br/>
<br/>
Начнем с <b>автоматических модулей</b>. Автоматический модуль — это jar-файл, поставленный в modulepath. После того, как вы его туда запишете, можно будет ответить на три следующих вопроса об этом модуле: <br/>
<br/>
В: Каково его имя?<br/>
О: это имя jar-файла. Если вы поставите в путь к модулям файл guava.jar, то получите автоматический модуль guava. <br/>
<br/>
Это также означает, что вы не сможете использовать Jar прямо из репозитория Maven, так как guava-18.0 не является допустимым идентификатором Java.<br/>
<br/>
В: Что он экспортирует?<br/>
О: Автоматический модуль экспортирует все свои пакеты. Итак, все публичные типы будут доступны любому модулю, читающему автоматический модуль.<br/>
<br/>
В: Что он требует?<br/>
О: Автоматический модуль читает все (*all*) прочие доступные модули (включая безымянный, подробнее об этом ниже). Это важно! Из автоматического модуля можно получить доступ ко всем экспортированным типам любого модуля. Этот момент нигде не нужно указывать, он подразумевается.<br/>
<br/>
Рассмотрим пример. Мы начинаем использовать com.google.common.base.Strings в zipvalidator-е. Чтобы разрешить такой доступ, мы должны определить ребро считывания для автоматического модуля Guava:<br/>
<br/>
<pre><code class="java">module de.codecentric.zipvalidator{
       exports de.codecentric.zipvalidator.api;
       requires public de.codecentric.zipvalidator.model;
       requires guava;

 }
</code></pre><br/>
<br/>
Для компиляции потребуется указать файл guava.jar в пути к модулям (он находится в каталоге ../jars):<br/>
<pre><code class="java">
javac -d . -modulepath ../jars -modulesourcepath .  $(find . -name &quot;*.java&quot;)
</code></pre><br/>
<br/>
Все прекрасно компилируется и запускается.<br/>
<br/>
(Между прочим, было не так просто запустить эту пример. Работая со сборкой Jigsaw 86, я столкнулся с некоторыми проблемами: система ругалась по поводу зависимостей от модуля <code>jdk.management.resource<br/>
</code>. Я спросил об этом в рассылке, обсуждение находится <a href="http://mail.openjdk.java.net/pipermail/jigsaw-dev/2015-November/005190.html">здесь</a>. <br/>
<br/>
Нужно сказать, что в моем решении я не пользовался «ранней» сборкой (early access build), а собирал JDK сам. При работе с OSX Mavericks возникли еще некоторые проблемы, о чем написано в треде, пришлось изменить makefile, но в итоге я все наладил. Возможно, вам при работе со следующими релизами придется столкнуться уже с другими проблемами).<br/>
<br/>
Теперь самое время познакомить вас с палочкой-выручалочкой, которая незаменима при переходе на Jigsaw. Этот инструмент называется <code>jdeps<br/>
</code>. Он просматривает ваш немодуляризованный код и сообщает вам о зависимостях. <br/>
<br/>
Рассмотрим guava:<br/>
<br/>
jdeps -s ../jars/guava.jar<br/>
Имеем такой вывод:<br/>
guava.jar -&gt; java.base<br/>
guava.jar -&gt; java.logging<br/>
guava.jar -&gt; not found<br/>
<br/>
Это означает, что автоматический модуль guava требует <code>java.base<br/>
</code>, <code>java.logging<br/>
</code> и … “не найдено“?! Что такое? Если убрать переключатель <code>-s<br/>
</code>, то<code> jdeps<br/>
</code> уходит с уровня модулей и спускается на шаг вниз, на уровень пакетов (список немного сокращен, так как пакетов у guava довольно много):<br/>
<br/>
<pre><code class="java">   com.google.common.xml (guava.jar)
      -&gt; com.google.common.escape               guava.jar
      -&gt; java.lang
      -&gt; javax.annotation                                   not found
</code></pre><br/>
<br/>
Здесь видно, что пакет <code>com.google.common.xml<br/>
</code> зависит от <code>com.google.common.escape<br/>
</code>, который расположен в самом модуле, <code>java.lang<br/>
</code>, который хорошо известен, и от аннотации<code> javax.annotation<br/>
</code>, которая не найдена. Делаем вывод, что нам нужен jar с типами JSR-305, поскольку там содержится <code>javax.annotation<br/>
</code> (кстати, я без них обхожусь – в моих примерах мне не требуется ни один тип из этих пакетов, и ни компилятор, ни исполняющая среда при этом не возражают).<br/>
<br/>
<b>Безымянный модуль</b><br/>
<br/>
Итак, что же такое безымянный модуль? Вновь ответим на три вопроса:<br/>
<br/>
В: Какого его имя?<br/>
О: Как вы уже догадались, имени у него нет <br/>
<br/>
В: Что он экспортирует?<br/>
О: Безымянный модуль экспортирует все свои пакеты любому другому модулю. Это не означает, что его можно читать из любого другого модуля – у него нет имени, и вы не можете его требовать! Команда requires unnamed; не сработает.<br/>
<br/>
В: Что он требует?<br/>
О: Безымянный модуль читает <b>все</b> прочие доступные модули.<br/>
<br/>
Итак, если вы не можете прочитать безымянный модуль из любых ваших модулей, то в чем же суть? На этот вопрос помогает ответить наш старый знакомый — путь к классам. Любой тип, считанный из пути к классам (а не из пути к модулям), автоматически помещается в безымянном модуле — или, иными словами, любой тип в безымянном модуле загружается через путь к классам. Поскольку безымянный модуль читает все другие модули, мы можем обратиться ко всем экспортированным типам из любого типа, загруженного через путь к классам. В Java 9 использование пути к классам и пути к модулям будет поддерживаться как по отдельности, так и совместно, для обеспечения обратной совместимости. Рассмотрим несколько примеров.<br/>
<br/>
Предположим, у нас есть аккуратный модуль zipvalidator, но addresschecker по-прежнему не модуляризован, у него нет <code>module-info.java<br/>
</code>. Структура наших исходников будет такой:<br/>
<br/>
<pre><code class="java">one-module-with-unnamed-ok/
├── classpath
│   └── de.codecentric.legacy.addresschecker
│       └── de
│           └── codecentric
│               └── legacy
│                   └── addresschecker
│                       ├── api
│                       │   ├── AddressChecker.java
│                       │   └── Run.java
│                       └── internal
│                           └── AddressCheckerImpl.java
├── modulepath
│   └── de.codecentric.zipvalidator
│       ├── de
│       │   └── codecentric
│       │       └── zipvalidator
│       │           ├── api
│       │           │   ├── ZipCodeValidator.java
│       │           │   └── ZipCodeValidatorFactory.java
│       │           └── internal
│       │               └── ZipCodeValidatorImpl.java
│       └── module-info.java
</code></pre><br/>
<br/>
Теперь есть один каталог classpath, в котором содержится унаследованный код, завязанный на доступ к zipvalidator, а также каталог modulepath, содержащий модуль zipvalidator. Мы можем компилировать наши модули как обычно. Чтобы скомпилировать унаследованный код, нам потребуется предоставить информацию о модульном коде. Просто запишем ее в путь к классам:<br/>
<pre><code class="java">
javac -d classpath/de.codecentric.legacy.addresschecker
  -classpath modulepath/de.codecentric.zipvalidator/ $(find classpath -name &quot;*.java&quot;)
</code></pre><br/>
<br/>
Все работает как обычно.<br/>
<br/>
Во время исполнения перед нами открывается две возможности. А именно:<br/>
<ul>
<li>Записать модуль в путь к классам</li>
<li>Смешать путь к классам и путь к модулям</li>
</ul><br/>
<br/>
Выбирая первый вариант, мы, фактически, отказываемся от модульной системы. Все типы, которые мы запишем в безымянный модуль, теперь смогут свободно обращаться друг к другу.<br/>
<br/>
<pre><code class="java">java -cp modulepath/de.cc.zipvalidator/:classpath/de.cc.legacy.addresschecker/
    de.codecentric.legacy.addresschecker.api.Run 76185
</code></pre><br/>
<br/>
работает точно как java-приложение, используемое вами сегодня.<br/>
<br/>
С другой стороны, смешанное использование пути к модулям и пути к классам работает так:<br/>
<br/>
<pre><code class="java">java -modulepath modulepath  -addmods de.codecentric.zipvalidator
    -classpath classpath/de.codecentric.legacy.addresschecker/
    de.codecentric.legacy.addresschecker.api.Run
</code></pre><br/>
<br/>
Используем одновременно два переключателя: <code>-classpath<br/>
</code> и <code>-modulepath<br/>
</code>. Добавлен переключатель <code>-addmods<br/>
</code> – при смешивании пути к классам и пути к модулям, мы не можем просто так получить доступ к любому модулю в каталогах modulepath, а должны конкретно указать, какие из них должны быть доступны.<br/>
<br/>
Этот подход также работает нормально, но здесь есть загвоздка! Помните, ответ на вопрос “чего требует безымянный модуль” — это “все другие модули”. Если мы будем использовать модуль zipvalidator через modulepath, то сможем работать лишь с его экспортированными пакетами. Все остальное приведет к IllegalAccessError во время исполнения. Поэтому в таком случае вам придется придерживаться правил системы модулей.<br/>
<br/>
<b>Создание образов исполняющей среды при помощи jlink</b><br/>
<br/>
Достаточно примеров с модулями; появился еще один новый инструмент, заслуживающий нашего внимания. <code>jlink<br/>
</code> – это утилита Java 9 для создания собственных дистрибутивов JVM. Самое интересное, что, благодаря новой модульной архитектуре JDK, вы можете сами выбирать, какие модули хотите включить в этот дистрибутив! Рассмотрим пример. Если мы хотим создать образ исполняющей среды, содержащий наш addresschecker, то даем команду:<br/>
<br/>
<pre><code class="java">jlink --modulepath $JAVA9_BIN/../../images/jmods/:two-modules-ok/
    --addmods de.codecentric.addresschecker --output linkedjdk

</code></pre><br/>
Указываем всего три вещи:<br/>
<br/>
<ul>
<li>Путь к модулям (в том числе, наши специальные модули и путь к каталогу jmods в вашем JDK – здесь находятся стандартные модули java)</li>
<li>Модули, которые вы хотите включить в ваш дистрибутив</li>
<li>Каталог вывода</li>
</ul><br/>
<br/>
Команда создает следующую структуру:<br/>
<br/>
linkedjdk/<br/>
├── bin<br/>
│ ├── java<br/>
│ └── keytool<br/>
├── conf<br/>
│ ├── net.properties<br/>
│ └── security<br/>
│ ├── java.policy<br/>
│ └── java.security<br/>
└── lib<br/>
 ├── classlist<br/>
 ├── jli<br/>
<pre><code class="java">    │   └── libjli.dylib
    ├── jspawnhelper
    ├── jvm.cfg
    ├── libjava.dylib
    ├── libjimage.dylib
    ├── libjsig.diz
    ├── libjsig.dylib
    ├── libnet.dylib
    ├── libnio.dylib
    ├── libosxsecurity.dylib
    ├── libverify.dylib
    ├── libzip.dylib
    ├── modules
    │   └── bootmodules.jimage
    ├── security
    │   ├── US_export_policy.jar
    │   ├── blacklisted.certs
    │   ├── cacerts
    │   └── local_policy.jar
    ├── server
    │   ├── Xusage.txt
    │   ├── libjsig.diz
    │   ├── libjsig.dylib
    │   ├── libjvm.diz
    │   └── libjvm.dylib
    └── tzdb.dat
</code></pre><br/>
<br/>
Вот и все. В OSX Mavericks все это занимает примерно 47 MB. Мы также можем задействовать архивацию и удалить некоторые отладочные возможности, которые все равно не понадобятся нам в продакшене. Самый компактный дистрибутив, который мне удалось создать, получился при помощи такой команды: <br/>
<br/>
<pre><code class="java">
jlink --modulepath $JAVA9_BIN/../../images/jmods/:two-modules-ok/bin
    --addmods de.codecentric.addresschecker --output linkedjdk --exclude-files *.diz
    --compress-resources on --strip-java-debug on --compress-resources-level 2
</code></pre><br/>
<br/>
Размер дистрибутива уменьшается примерно до 18 MB, по-моему – просто великолепно. В Linux, вероятно, можно ужаться и до 13.<br/>
<br/>
При вызове<br/>
<br/>
<pre><code class="java">/bin/java --listmods
</code></pre><br/>
<br/>
Выводится список модулей, содержащихся в этом дистрибутиве<br/>
<br/>
<pre><code class="java">de.codecentric.addresschecker
de.codecentric.zipvalidator
java.base@9.0
</code></pre><br/>
<br/>
Итак, все приложения, зависящие от максимального количества этих модулей, могут работать на данной JVM. Но мне не удалось получить наш основной класс для запуска этого сценария. Для этого я пошел другим путем. <br/>
<br/>
Внимательный читатель мог заметить, что второй вызов делается к jlink, и путь к модулям там иной, нежели при первом вызове. Во втором случае мы указываем путь к каталогу bin. Этот каталог содержит модульные jar-файлы, и jar для addresschecker также содержит в своем манифесте информацию об основном классе. Утилита jlink использует эту информацию, чтобы добавить дополнительную информацию в bin-каталог нашей JVM:<br/>
<br/>
<pre><code class="java">linkedjdk/
├── bin
│   ├── de.codecentric.addresschecker
│   ├── java
│   └── keytool
...
</code></pre><br/>
<br/>
Итак, теперь мы можем вызывать наше приложение напрямую. Красота!<br/>
<br/>
<pre><code class="java">./linkedjdk/bin/de.codecentric.addresschecker 76185
</code></pre><br/>
<br/>
выводит<br/>
<br/>
<code>76185 is a valid zip code<br/>
</code><br/>
<br/>
<b>Заключение</b><br/>
<br/>
Вот и подошло к концу наше знакомство с Jigsaw. Мы рассмотрели ряд примеров, иллюстрирующих, что можно и чего нельзя сделать при помощи Jigsaw и Java 9. Jigsaw привносит коренные изменения, которые нельзя так запросто компенсировать при помощи лямбда-выражений или ресурсов<code> try-with<br/>
</code>. Весь наш тулчейн от сборочных инструментов вроде Maven или Gradle до IDE придется адаптировать к модульной системе. На конференции JavaOne Ханс Доктер из Gradle Inc. прочитал доклад о том, как можно приступить к написанию модульного кода даже на Java 8 и ниже. Gradle выполняет проверку во время компиляции и выдает отказ, если целостность модуля оказывается нарушена. Эта (экспериментальная) возможность была включена в последний релиз <a href="https://docs.gradle.org/current/release-notes#explicit-declaration-of-library-api-with-the-experimental-java-software-model">Gradle 2.9</a>. Нас определенно ждут интересные времена!<br/>
<br/>
Для более подробного знакомства с Jigsaw вновь рекомендую вам домашнюю страницу <a href="http://openjdk.java.net/projects/jigsaw/">Jigsaw Project</a>, особенно <a href="http://openjdk.java.net/projects/jigsaw/j1/">слайды и видео</a> докладов о Jigsaw с последней конференции JavaOne.</div>


Статья пятая

Название: Обработка строк в Java. Часть I: String, StringBuffer, StringBuilder



<h3>Вступление</h3><br/>
Что вы знаете о обработке строк в Java? Как много этих знаний и насколько они углублены и актуальны? Давайте попробуем вместе со мной разобрать все вопросы, связанные с этой важной, фундаментальной и часто используемой частью языка. Наш маленький гайд будет разбит на две публикации:<br/>
<br/>
<ol>
<li><a href="http://habrahabr.ru/post/260767/">String, StringBuffer, StringBuilder (реализация строк)</a></li>
<li><a href="http://habrahabr.ru/post/260773/">Pattern, Matcher (регулярные выражения)</a></li>
</ol><br/>
Реализация строк на Java представлена тремя основными классами: <b>String</b>, <b>StringBuffer</b>, <b>StringBuilder</b>. Давайте поговорим о них.<br/>
<a name="habracut"></a><br/>
<h3>String</h3><br/>
Строка — объект, что представляет последовательность символов. Для создания и манипулирования строками Java платформа предоставляет общедоступный финальный (не может иметь подклассов) класс <b>java.lang.String</b>. Данный класс является неизменяемым (<i>immutable</i>) — созданный объект класса <b>String</b> не может быть изменен. Можно подумать что методы имеют право изменять этот объект, но это неверно. Методы могут только создавать и возвращать новые строки, в которых хранится результат операции. Неизменяемость строк предоставляет ряд возможностей:<br/>
<br/>
<ul>
<li>использование строк в многопоточных средах (<b>String</b> является потокобезопасным (thread-safe) )</li>
<li>использование <b>String Pool</b> (это коллекция ссылок на <b>String</b> объекты, используется для оптимизации памяти)</li>
<li>использование строк в качестве ключей в <b>HashMap</b> (ключ рекомендуется делать неизменяемым)</li>
</ul><br/>
<h4>Создание</h4><br/>
Мы можем создать объект класса <b>String</b> несколькими способами:<br/>
<br/>
<h5>1. Используя строковые литералы:</h5><br/>
<pre><code class="java">String habr = &quot;habrahabr&quot;;
</code></pre><br/>
Строковый литерал — последовательность символов заключенных в двойные кавычки. Важно понимать, что всегда когда вы используете строковой литерал компилятор создает объект со значением этого литерала:<br/>
<br/>
<pre><code class="java">System.out.print(&quot;habrahabr&quot;); // создали объект и вывели его значение
</code></pre><br/>
<h5>2. С помощью конструкторов:</h5><br/>
<pre><code class="java">String habr = &quot;habrahabr&quot;;
char[] habrAsArrayOfChars = {'h', 'a', 'b', 'r', 'a', 'h', 'a', 'b', 'r'};
byte[] habrAsArrayOfBytes = {104, 97, 98, 114, 97, 104, 97, 98, 114};

String first = new String();
String second = new String(habr);
</code></pre><br/>
Если копия строки не требуется явно, использование этих конструкторов нежелательно и в них нет необходимости, так как строки являются неизменными. Постоянное строительство новых объектов таким способом может привести к снижению производительности. Их лучше заменить на аналогичные инициализации с помощью строковых литералов.<br/>
<br/>
<pre><code class="java">String third = new String(habrAsArrayOfChars); // &quot;habrahabr&quot;
String fourth = new String(habrAsArrayOfChars, 0, 4); // &quot;habr&quot;
</code></pre><br/>
Конструкторы могут формировать объект строки с помощью массива символов. Происходит копирование массива, для этого используются статические методы <b>copyOf</b> и <b>copyOfRange</b> (копирование всего массива и его части (если указаны 2-й и 3-й параметр конструктора) соответственно) класса <b>Arrays</b>, которые в свою очередь используют платформо-зависимую реализацию <b>System.arraycopy</b>.<br/>
<br/>
<pre><code class="java">String fifth = new String(habrAsArrayOfBytes, Charset.forName(&quot;UTF-16BE&quot;)); // кодировка нам явно не подходит &quot;桡扲慨慢�&quot;
</code></pre><br/>
Можно также создать объект строки с помощью массива байтов. Дополнительно можно передать параметр класса <b>Charset</b>, что будет отвечать за кодировку. Происходит декодирование массива с помощью указанной кодировки (если не указано — используется <b>Charset.defaultCharset()</b>, который зависит от кодировки операционной системы) и, далее, полученный массив символов копируется в значение объекта.<br/>
<br/>
<pre><code class="java">String sixth = new String(new StringBuffer(habr));
String seventh = new String(new StringBuilder(habr));
</code></pre><br/>
Ну и наконец-то конструкторы использующие объекты <b>StringBuffer</b> и <b>StringBuilder</b>, их значения (<b>getValue()</b>) и длину (<b>length()</b>) для создания объекта строки. С этими классами мы познакомимся чуть позже.<br/>
<br/>
Приведены примеры наиболее часто используемых конструкторов класса <b>String</b>, на самом деле их пятнадцать (два из которых помечены как <i>deprecated</i>).<br/>
<br/>
<h4>Длина</h4><br/>
Важной частью каждой строки есть ее длина. Узнать ее можно обратившись к объекту <b>String</b> с помощью метода доступа (<i>accessor method</i>) <b>length()</b>, который возвращает количество символов в строке, например:<br/>
<br/>
<pre><code class="java">public static void main(String[] args) {
    String habr = &quot;habrahabr&quot;;
    // получить длину строки
    int length = habr.length();
    // теперь можно узнать есть ли символ символ 'h' в &quot;habrahabr&quot;
    char searchChar = 'h';
    boolean isFound = false;
    for (int i = 0; i &lt; length; ++i) {
        if (habr.charAt(i) == searchChar) {
            isFound = true;
            break; // первое вхождение
        }
    }
    System.out.println(message(isFound)); // Your char had been found!
    // ой, забыл, есть же метод indexOf
    System.out.println(message(habr.indexOf(searchChar) != -1)); // Your char had been found!
}

private static String message(boolean b) {
    return &quot;Your char had&quot; + (b ? &quot; &quot; : &quot;n't &quot;) + &quot;been found!&quot;;
}
</code></pre><br/>
<h4>Конкатенация</h4><br/>
Конкатенация — операция объединения строк, что возвращает новую строку, что есть результатом объединения второй строки с окончанием первой. Операция для объекта <b>String</b> может быть выполнена двумя способами:<br/>
<br/>
<h5>1. Метод <b>concat</b></h5><br/>
<pre><code class="java">String javaHub = &quot;habrhabr&quot;.concat(&quot;.ru&quot;).concat(&quot;/hub&quot;).concat(&quot;/java&quot;);
System.out.println(javaHub); // получим &quot;habrhabr.ru/hub/java&quot;
// перепишем наш метод используя concat
private static String message(boolean b) {
    return &quot;Your char had&quot;.concat(b ? &quot; &quot; : &quot;n't &quot;).concat(&quot;been found!&quot;);
}
</code></pre><br/>
Важно понимать, что метод <b>concat</b> не изменяет строку, а лишь создает новую как результат слияния текущей и переданной в качестве параметра. Да, метод возвращает новый объект String, поэтому возможны такие длинные «цепочки».<br/>
<br/>
<h5>2. Перегруженные операторы &quot;<b>+</b>&quot; и &quot;<b>+=</b>&quot;</h5><br/>
<pre><code class="java">String habr = &quot;habra&quot; + &quot;habr&quot;; // &quot;habrahabr&quot;
habr += &quot;.ru&quot;; // &quot;habrahabr.ru&quot;
</code></pre><br/>
Это одни с немногих перегруженных операторов в Java — язык не позволяет перегружать операции для объектов пользовательских классов. Оператор &quot;+&quot; не использует метод <b>concat</b>, тут используется следующий механизм:<br/>
 <br/>
<pre><code class="java">String habra = &quot;habra&quot;;
String habr = &quot;habr&quot;;
// все просто и красиво
String habrahabr = habra + habr;
// а на самом деле
String habrahabr = new StringBuilder()).append(habra).append(habr).toString(); // может быть использован StringBuffer
</code></pre><br/>
Используйте метод <b>concat</b>, если слияние нужно провести только один раз, для остальных случаев рекомендовано использовать или оператор &quot;<b>+</b>&quot; или <b>StringBuffer</b> / <b>StringBuilder</b>. Также стоит отметить, что получить NPE (<b>NullPointerException</b>), если один с операндов равен <b>null</b>, невозможно с помощью оператора &quot;<b>+</b>&quot; или &quot;<b>+=</b>&quot;, чего не скажешь о методе <b>concat</b>, например:<br/>
<br/>
<pre><code class="java">String string = null;
string += &quot; habrahabr&quot;; // null преобразуется в &quot;null&quot;, в результате &quot;null habrahabr&quot;
string = null;
string.concat(&quot;s&quot;); // логично что NullPointerException
</code></pre><br/>
<h4>Форматирование</h4><br/>
Класс <b>String</b> предоставляет возможность создания форматированных строк. За это отвечает статический метод <b>format</b>, например:<br/>
<br/>
<pre><code class="java">String formatString = &quot;We are printing double variable (%f), string ('%s') and integer variable (%d).&quot;;
System.out.println(String.format(formatString, 2.3, &quot;habr&quot;, 10));
// We are printing double variable (2.300000), string ('habr') and integer variable (10).
</code></pre><br/>
<h4>Методы</h4><br/>
Благодаря множеству методов предоставляется возможность манипулирования строкой и ее символами. Описывать их здесь нет смысла, потому что Oracle имеет хорошие статьи о <a href="https://docs.oracle.com/javase/tutorial/java/data/manipstrings.html">манипулировании</a> и <a href="https://docs.oracle.com/javase/tutorial/java/data/comparestrings.html">сравнении</a> строк. Также у вас под рукой всегда есть их <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html">документация</a>. Хотелось отметить новый статический метод <b>join</b>, который появился в Java 8. Теперь мы можем удобно объединять несколько строк в одну используя разделитель (был добавлен класс <b>java.lang.StringJoiner</b>, что за него отвечает), например:<br/>
<br/>
<pre><code class="java">String hello = &quot;Hello&quot;;
String habr = &quot;habrahabr&quot;;
String delimiter = &quot;, &quot;;

System.out.println(String.join(delimiter, hello, habr));
// или так
System.out.println(String.join(delimiter, new ArrayList&lt;CharSequence&gt;(Arrays.asList(hello, habr))));
// в обоих случаях &quot;Hello, habrahabr&quot;
</code></pre><br/>
Это не единственное изменение класса в Java 8. Oracle <a href="http://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html">сообщает</a> о улучшении производительности в конструкторе <b>String(byte[], *)</b> и методе <b>getBytes()</b>.<br/>
<br/>
<h4>Преобразование</h4><br/>
<h5>1. Число в строку</h5><br/>
<pre><code class="java">int integerVariable = 10;
String first = integerVariable + &quot;&quot;; // конкатенация с пустой строкой
String second = String.valueOf(integerVariable); // вызов статического метода valueOf класса String
String third = Integer.toString(integerVariable); // вызов метода toString класса-обертки
</code></pre><br/>
<h5>2. Строку в число</h5><br/>
<pre><code class="java">String string = &quot;10&quot;;
int first = Integer.parseInt(string);
/*
   получаем примитивный тип (primitive type)
   используя метод parseXхх нужного класса-обертки,
   где Xxx - имя примитива с заглавной буквы (например parseInt)
*/
int second = Integer.valueOf(string); // получаем объект wrapper класса и автоматически распаковываем
</code></pre><br/>
<br/>
<h3>StringBuffer</h3><br/>
Строки являются неизменными, поэтому частая их модификация приводит к созданию новых объектов, что в свою очередь расходует драгоценную память. Для решения этой проблемы был создан класс <b>java.lang.StringBuffer</b>, который позволяет более эффективно работать над модификацией строки. Класс является <i>mutable</i>, то есть изменяемым — используйте его, если Вы хотите изменять содержимое строки. <b>StringBuffer</b> может быть использован в многопоточных средах, так как все необходимые методы являются синхронизированными.<br/>
<br/>
<h4>Создание</h4><br/>
Существует четыре способа создания объекта класса <b>StringBuffer</b>. Каждый объект имеет свою вместимость (<i>capacity</i>), что отвечает за длину внутреннего буфера. Если длина строки, что хранится в внутреннем буфере, не превышает размер этого буфера (<i>capacity</i>), то нет необходимости выделять новый массив буфера. Если же буфер переполняется — он автоматически становиться больше.<br/>
<br/>
<pre><code class="java">StringBuffer firstBuffer = new StringBuffer(); // capacity = 16
StringBuffer secondBuffer = new StringBuffer(&quot;habrahabr&quot;); // capacity = str.length() + 16
StringBuffer thirdBuffer = new StringBuffer(secondBuffer); // параметр - любой класс, что реализует CharSequence
StringBuffer fourthBuffer = new StringBuffer(50); // передаем capacity
</code></pre><br/>
<h4>Модификация</h4><br/>
В большинстве случаев мы используем <b>StringBuffer</b> для многократного выполнения операций добавления (<i>append</i>), вставки (<i>insert</i>) и удаления (<i>delete</i>) подстрок. Тут все очень просто, например:<br/>
<br/>
<pre><code class="java">String domain = &quot;.ru&quot;;
// создадим буфер с помощью String объекта
StringBuffer buffer = new StringBuffer(&quot;habrahabr&quot;); // &quot;habrahabr&quot;
// вставим домен в конец
buffer.append(domain); // &quot;habrahabr.ru&quot;
// удалим домен
buffer.delete(buffer.length() - domain.length(), buffer.length()); // &quot;habrahabr&quot;
// вставим домен в конец на этот раз используя insert
buffer.insert(buffer.length(), domain); // &quot;habrahabr.ru&quot;
</code></pre><br/>
Все остальные методы для работы с <b>StringBuffer</b> можно посмотреть в <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html">документации</a>.<br/>
<br/>
<h3>StringBuilder</h3><br/>
<b>StringBuilder</b> — класс, что представляет изменяемую последовательность символов. Класс был введен в Java 5 и имеет полностью идентичный API с <b>StringBuffer</b>. Единственное отличие — <b>StringBuilder</b> не синхронизирован. Это означает, что его использование в многопоточных средах есть нежелательным. Следовательно, если вы работаете с многопоточностью, Вам идеально подходит <b>StringBuffer</b>, иначе используйте <b>StringBuilder</b>, который работает намного быстрее в большинстве реализаций. Напишем небольшой тест для сравнения скорости работы этих двух классов:<br/>
<br/>
<pre><code class="java">public class Test {
    public static void main(String[] args) {
        try {
            test(new StringBuffer(&quot;&quot;)); // StringBuffer: 35117ms.
            test(new StringBuilder(&quot;&quot;)); // StringBuilder: 3358ms.
        } catch (java.io.IOException e) {
            System.err.println(e.getMessage());
        }
    }
    private static void test(Appendable obj) throws java.io.IOException {
        // узнаем текущее время до теста
        long before = System.currentTimeMillis();
        for (int i = 0; i++ &lt; 1e9; ) {
            obj.append(&quot;&quot;);
        }
        // узнаем текущее время после теста
        long after = System.currentTimeMillis();
        // выводим результат
        System.out.println(obj.getClass().getSimpleName() + &quot;: &quot; + (after - before) + &quot;ms.&quot;);
    }
}
</code></pre><br/>
Спасибо за внимание. Надеюсь статья поможет узнать что-то новое и натолкнет на удаление всех пробелов в этих вопросах. Все дополнения, уточнения и критика приветствуются.



Статья Шестая

Название
Обработка строк в Java. Часть II: Pattern, Matcher


Что Вы знаете о обработке строк в Java? Как много этих знаний и насколько они углублены и актуальны? Давайте попробуем вместе со мной разобрать все вопросы, связанные с этой важной, фундаментальной и часто используемой частью языка. Наш маленький гайд будет разбит на две публикации:<br/>
<br/>
<ol>
<li><a href="http://habrahabr.ru/post/260767/">String, StringBuffer, StringBuilder (реализация строк)</a></li>
<li><a href="http://habrahabr.ru/post/260773/">Pattern, Matcher (регулярные выражения)</a></li>
</ol><br/>
Сегодня поговорим о регулярных выражениях в Java, рассмотрим их механизм и подход к обработке. Также рассмотрим функциональные возможности пакета <b>java.util.regex</b>.<br/>
 <a name="habracut"></a><br/>
<hr/><br/>
<h3>Регулярные выражения</h3><br/>
Регулярные выражения (<i>regular expressions</i>, далее РВ) — мощное и эффективное средство для обработки текста. Они впервые были использованы в текстовых редакторах операционной системы UNIX (<a href="https://en.wikipedia.org/wiki/Ed_%28text_editor%29">ed</a> и <a href="https://en.wikipedia.org/wiki/QED_%28text_editor%29">QED</a>) и сделали прорыв в электронной обработке текстов конца XX века. В 1987 году более сложные РВ возникли в первой версии языка Perl и были основаны на пакете Henry Spencer (1986), написанном на языке С. А в 1997 году, Philip Hazel разработал <a href="http://www.pcre.org/">Perl Compatible Regular Expressions</a> (PCRE) — библиотеку, что точно наследует функциональность РВ в Perl. Сейчас PCRE используется многими современными инструментами, например <a href="http://httpd.apache.org/">Apache HTTP Server</a>.<br/>
<div style="text-align:center;"><img src="https://habrastorage.org/files/fd1/350/d27/fd1350d27bb84df199ac607154b0c835.png" /></div><br/>
Большинство современных языков программирования поддерживают РВ, Java не является исключением.<br/>
<br/>
<h3>Механизм</h3><br/>
Существует две базовые технологии, на основе которых строятся механизмы РВ:<br/>
<br/>
<ul>
<li>Недетерминированный конечный автомат (НКА) — «механизм, управляемый регулярным выражением»</li>
<li>Детерминированный конечный автомат (ДКА) — «механизм, управляемый текстом»</li>
</ul><br/>
НКА — механизм, в котором управление внутри РВ передается от компонента к компоненту. НКА просматривает РВ по одному компоненту и проверяет, совпадает ли компонент с текстом. Если совпадает — проверятся следующий компонент. Процедура повторяется до тех пор, пока не будет найдено совпадение для всех компонентов РВ (пока не получим общее совпадение).<br/>
<br/>
ДКА — механизм, который анализирует строку и следит за всеми «возможными совпадениями». Его работа зависит от каждого просканированного символа текста (то есть ДКА «управляется текстом»). Даний механизм сканирует символ текста, обновляет «потенциальное совпадение» и резервирует его. Если следующий символ аннулирует «потенциальное совпадение», то ДКА возвращается к резерву. Нет резерва — нет совпадений.<br/>
<br/>
Логично, что ДКА должен работать быстрее чем НКА (ДКА проверяет каждый символ текста не более одного раза, НКА — сколько угодно раз пока не закончит разбор РВ). Но НКА предоставляет возможность определять ход дальнейших событий. Мы можем в значительной степени управлять процессом за счет правильного написания РВ.<br/>
<br/>
<u><b>Регулярные выражения в Java используют механизм НКА.</b></u><br/>
<br/>
<i>Эти виды конечных автоматов более детально рассмотрены в статье <a href="http://habrahabr.ru/post/166777/">«Регулярные выражения изнутри»</a>.</i><br/>
<br/>
<h3>Подход к обработке</h3><br/>
В языках программирования существует три подхода к обработке РВ:<br/>
<br/>
<ul>
<li>интегрированный</li>
<li>процедурный</li>
<li>объектно-ориентированный</li>
</ul><br/>
Интегрированный подход — встраивание РВ в низкоуровневый синтаксис языка. Этот подход скрывает всю механику, настройку и, как следствие, упрощает работу программиста.<br/>
Функциональность РВ при процедурном и объектно-ориентированном подходе обеспечивают функции и методы соответственно. Вместо специальных конструкций языка, функции и методы принимают в качестве параметров строки и интерпретируют их как РВ.<br/>
<br/>
<u><b>Для обработки регулярных выражений в Java используют объектно-ориентированный подход.</b></u><br/>
<br/>
<h3>Реализация</h3><br/>
Для работы с регулярными выражениями в Java представлен пакет <b>java.util.regex</b>. Пакет был добавлен в версии 1.4 и уже тогда содержал мощный и современный прикладной интерфейс для работы с регулярными выражениями. Обеспечивает хорошую гибкость из-за использования объектов, реализующих интерефейс <b>CharSequence</b>.<br/>
Все функциональные возможности представлены двумя классами, интерфейсом и исключением:<br/>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/434/23d/2ec/43423d2ecc54f9a3738e89480634df85.png" /></div><br/>
<h4>Pattern</h4><br/>
Класс <b>Pattern</b> представляет собой скомпилированное представление РВ. Класс не имеет публичных конструкторов, поэтому для создания объекта данного класса необходимо вызвать статический метод <b>compile</b> и передать в качестве первого аргумента строку с РВ:<br/>
<br/>
<pre><code class="java">// XML тэг в формате &lt;xxx&gt;&lt;/xxx&gt;
Pattern pattern = Pattern.compile(&quot;^&lt;([a-z]+)([^&gt;]+)*(?:&gt;(.*)&lt;\\/\\1&gt;|\\s+\\/&gt;)$&quot;);
</code></pre><br/>
Также в качестве второго параметра в метод <b>compile</b> можно передать флаг в виде статической константы класса <b>Pattern</b>, например:<br/>
<br/>
<pre><code class="java">// email адрес в формате xxx@xxx.xxx (регистр букв игнорируется)
Pattern pattern = Pattern.compile(&quot;^([a-z0-9_\\.-]+)@([a-z0-9_\\.-]+)\\.([a-z\\.]{2,6})$&quot;, Pattern.CASE_INSENSITIVE);
</code></pre><br/>
Таблица всех доступных констант и эквивалентных им флагов: <br/>
<table>
<tr>
<th>№</th>
<th>Constant</th>
<th>Equivalent Embedded Flag Expression</th>
</tr>
<tr>
<td>1</td>
<td>Pattern.CANON_EQ</td>
<td>-</td>
</tr>
<tr>
<td>2</td>
<td>Pattern.CASE_INSENSITIVE</td>
<td>(?i)</td>
</tr>
<tr>
<td>3</td>
<td>Pattern.COMMENTS</td>
<td>(?x)</td>
</tr>
<tr>
<td>4</td>
<td>Pattern.MULTILINE</td>
<td>(?m)</td>
</tr>
<tr>
<td>5</td>
<td>Pattern.DOTALL</td>
<td>(?s)</td>
</tr>
<tr>
<td>6</td>
<td>Pattern.LITERAL</td>
<td>-</td>
</tr>
<tr>
<td>7</td>
<td>Pattern.UNICODE_CASE</td>
<td>(?u)</td>
</tr>
<tr>
<td>8</td>
<td>Pattern.UNIX_LINES</td>
<td>(?d)</td>
</tr>
</table>Иногда нам необходимо просто проверить есть ли в строке подстрока, что удовлетворяет заданному РВ. Для этого используют статический метод <b>matches</b>, например:<br/>
<br/>
<pre><code class="java">// это hex код цвета?
if (Pattern.matches(&quot;^#?([a-f0-9]{6}|[a-f0-9]{3})$&quot;, &quot;#8b2323&quot;)) { // вернет true
    // делаем что-то
}
</code></pre> <br/>
Также иногда возникает необходимость разбить строку на массив подстрок используя РВ. В этом нам поможет метод <b>split</b>:<br/>
<br/>
<pre><code class="java">Pattern pattern = Pattern.compile(&quot;:|;&quot;);
String[] animals = pattern.split(&quot;cat:dog;bird:cow&quot;);
Arrays.asList(animals).forEach(animal -&gt; System.out.print(animal + &quot; &quot;));
// cat dog bird cow
</code></pre><br/>
<h4>Matcher и MatchResult</h4><br/>
<b>Matcher</b> — класс, который представляет строку, реализует механизм согласования (<i>matching</i>) с РВ и хранит результаты этого согласования (используя реализацию методов интерфейса <b>MatchResult</b>). Не имеет публичных конструкторов, поэтому для создания объекта этого класса нужно использовать метод <b>matcher</b> класса <b>Pattern</b>:<br/>
<br/>
<pre><code class="java">// будем искать URL
String regexp = &quot;^(https?:\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w \\.-]*)*\\/?$&quot;;
String url = &quot;http://habrahabr.ru/post/260767/&quot;;

Pattern pattern = Pattern.compile(regexp);
Matcher matcher = pattern.matcher(url);
</code></pre><br/>
Но результатов у нас еще нет. Чтобы их получить нужно воспользоваться методом <b>find</b>. Можно использовать <b>matches</b> — этот метод вернет true только тогда, когда вся строка соответствует заданному РВ, в отличии от <b>find</b>, который пытается найти подстроку, которая удовлетворяет РВ. Для более детальной информации о результатах согласования можно использовать реализацию методов интерфейса <b>MatchResult</b>, например:<br/>
<br/>
<pre><code class="java">// IP адрес
String regexp = &quot;(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)&quot;;
// для сравнения работы find() и matches()
String goodIp = &quot;192.168.0.3&quot;;
String badIp = &quot;192.168.0.3g&quot;;

Pattern pattern = Pattern.compile(regexp);

Matcher matcher = pattern.matcher(goodIp);
// matches() - true, find() - true
matcher = pattern.matcher(badIp);
// matches() - false, find() - true

// а теперь получим дополнительную информацию
System.out.println(matcher.find() ?
        &quot;I found '&quot;+matcher.group()+&quot;' starting at index &quot;+matcher.start()+&quot; and ending at index &quot;+matcher.end()+&quot;.&quot; :
        &quot;I found nothing!&quot;);
// I found the text '192.168.0.3' starting at index 0 and ending at index 11.
</code></pre><br/>
Также можно начинать поиск с нужной позиции используя <b>find(int start)</b>. Стоит отметить что существует еще один способ поиска — метод <b>lookingAt</b>. Он начинает проверку совпадений РВ с начала строки, но не требует полного соответствия, в отличии от <b>matches</b>.<br/>
Класс предоставляет методы для замены текста в указанной строке:<br/>
<table>
<tr>
<td>appendReplacement(StringBuffer sb, String replacement)</td>
<td>Реализует механизм «добавление-и-замена» (<i>append-and-replace</i>). Формирует обьект <b>StringBuffer</b> (получен как параметр) добавляя replacement в нужные места. Устанавливает позицию, которая соответствует <b>end()</b> последнего результата поиска. После этой позиции ничего не добавляет.</td>
</tr>
<tr>
<td>appendTail(StringBuffer sb)</td>
<td>Используется после одного или нескольких вызовов <b>appendReplacement</b> и служит для добавления оставшейся части строки в объект класса <b>StringBuffer</b>, полученного как параметр.</td>
</tr>
<tr>
<td>replaceFirst(String replacement)</td>
<td>Заменяет <b>первую</b> последовательность, которая соответствует РВ, на replacement. Использует вызовы методов <b>appendReplacement</b> и <b>appendTail</b>.</td>
</tr>
<tr>
<td>replaceAll(String replacement)</td>
<td>Заменяет <b>каждую</b> последовательность, которая соответствует РВ, на replacement. Также использует методы <b>appendReplacement</b> и <b>appendTail</b>.</td>
</tr>
<tr>
<td>quoteReplacement(String s)</td>
<td>Возвращает строку, в которой коса черта (<b>' \ '</b>) и знак доллара (<b>' $ '</b>) будут лишены особого смысла.</td>
</tr>
</table><pre><code class="java">Pattern pattern = Pattern.compile(&quot;a*b&quot;);
Matcher matcher = pattern.matcher(&quot;aabtextaabtextabtextb the end&quot;);
StringBuffer buffer = new StringBuffer();

while (matcher.find()) {
    matcher.appendReplacement(buffer, &quot;-&quot;);
    // buffer = &quot;-&quot; -&gt; &quot;-text-&quot; -&gt; &quot;-text-text-&quot; -&gt; &quot;-text-text-text-&quot;
}
matcher.appendTail(buffer);
// buffer = &quot;-text-text-text- the end&quot;
</code></pre><br/>
<h4>PatternSyntaxException</h4><br/>
Неконтролируемое (<i>unchecked</i>) исключение, возникает при синтаксической ошибке в регулярном выражении. В таблице ниже приведены все методы и их описание.<br/>
<table>
<tr>
<td>getDescription()</td>
<td>Возвращает описание ошибки.</td>
</tr>
<tr>
<td>getIndex()</td>
<td>Возвращает индекс строки, где была найдена ошибка в РВ</td>
</tr>
<tr>
<td>getPattern()</td>
<td>Возвращает ошибочное РВ.</td>
</tr>
<tr>
<td>getMessage()</td>
<td>getDescription() + getIndex() + getPattern()</td>
</tr>
</table>Спасибо за внимание. Все дополнения, уточнения и критика приветствуются.



Статья седьмая


Немного о Java Collections Framework. Часть 1




В англоязычном сегменте сети достаточно много статьей по этой теме. Чаще всего они несут поверхностный, ознакомительный характер и иногда довольно сложно из-за языкового барьера уловить суть изучаемой темы. Надеюсь, наше небольшое путешествие в Java Collections Framework принесет вам некоторое разъяснение. Чем больше предметной информации, тем легче собрать всю мозаику воедино, отбрасывая не понятные выкладки и описания. Для более эффективного изучения количество примеров является критичным. Так же дело обстоит и с коллекциями, обойдем стороной интерфейсы, и перейдем сразу к классам, их реализующие.<br/>
<br/>
<h3>Класс ArrayList</h3><br/>
<blockquote><i>«Не стоит недооценивать важность метафор. Метафоры имеют одно неоспоримое достоинство: описываемое ими поведение предсказуемо и понятно всем людям…”.</i><br/>
Фернандо Дж. Корбати.</blockquote><br/>
<br/>
Я полностью согласен с Фернандо Дж. Корбати о важности метафор в изучение определённой предметной области. Так как программирование является смесью математики и искусства, использование метафор имеет наивысший приоритет. Для объяснения сути назначения <i>ArrayList</i> мы будем использовать «Транспортную» метафору. Представьте, что это обычный массив, похожий на семейный автомобиль, купленный с расчётом на количество членов семьи.<br/>
<br/>
<div style="text-align:center;"><img src="https://habrastorage.org/files/83a/c26/45d/83ac2645ddd04780ac369774ed7d494b.jpg" /></div><br/>
<br/>
Если у нашей семьи родиться ещё один ребёнок, то придется покупать более вместительный автомобиль. Предположим, родители заведомо не знают, сколько детей у них будет и какой ещё вместимости необходим новый автомобиль. Есть вероятность прогадать и зря потратить сбережения. Так вот, <i>ArrayList</i> подобна городскому транспорту. Здесь нет ограничений в вместимости. Каждый в состоянии доехать из пункта<b> A</b> в пункт <b>B</b>. Поэтому если отец семейства не уверен или не знает о количестве будущих детей, он выберет городской транспорт, или в нашем случае <i>ArrayList</i>. Данный класс имеет три конструктора, мы будем разбирать самый простой. Давайте напишем код.<br/>
<a name="habracut"></a><br/>
<pre><code class="java">import java.util.ArrayList;

 public class Collection {

	public static void main(String[] args) {

	// Создаем пустую коллекцию для работы с объектами класса Integer.
	ArrayList&lt;Integer&gt; IdCustomer = new ArrayList&lt;Integer&gt;();

	// Добавляем объекты в коллекцию.
	IdCustomer.add(1);
	IdCustomer.add(2);
	IdCustomer.add(3);

	// Выводим на консоль все значения объектов класса Integer,
	// коллекции  IdCustomer
	System.out.println(IdCustomer);

	// Роль данного вызова метода будет определена далее в статье.
         IdCustomer.remove(2);

	// После удаления элемента. выводим значения объектов класса Integer,
	System.out.println(IdCustomer);

	}
}
</code></pre><br/>
<br/>
<i><b>Вывод программы на консоль:</b><br/>
[1, 2, 3]<br/>
[1, 2]</i><br/>
<br/>
Программа очень интуитивно понятна и проста, но давайте немного копнем глубже и взглянем изнутри, как всё работает. Во-первых, класс <i>ArrayList </i>является обобщенным, относительно нашего объявления, мы должны работать с объектами класса <i>Integer</i>. Однако судя по коду программы этого не происходит. Установим <i>breakpoint </i>на строку: <pre><code class="java"> IdCustomer.add(2) </code></pre> запустим <i>Debug </i>и войдем в метод<i>(Step Into)</i>. Если всё прошло успешно, то обнаружим следующий код.<br/>
<br/>
<pre><code class="java">
public static Integer valueOf(int i) {
        if (i &gt;= IntegerCache.low && i &lt;= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
    }
</code></pre><br/>
Как видите, имя метода не совпадает с тем методом, в который мы входили, плюс ко всему мы оказались в классе <i>Integer</i>. Обратим наше внимание на строку: <br/>
<br/>
<pre><code class="java">
// Создание объекта класса Integer c int-значением внутри
// и передача адреса объекта вызывающему методу.
 return new Integer(i);
 </code></pre> <br/>
Это и есть знаменитая „Autoboxing Java“, из простого <i>int </i>в объект класса <i>Integer</i>. Теперь всё встало на свои места и вписывается в картину объявления обобщенного класса <i>ArrayList</i>. Далее рассмотрим метод добавления элемента в коллекцию.<br/>
<br/>
<pre><code class="java">
public boolean add(E e) {

// Проверка вместимости массива и его расширение, если вместимости не достаточно.
            ensureCapacityInternal(size + 1);
// Запись  элемента в массива. переданного в метод.
            elementData[size++] = e;
// Передача флага удачного выполнения метода.
            return true;
    }
</code></pre><br/>
Данный метод не только записывает элемент в коллекцию, но и поддерживает „транспортную“ метафору путем увеличение вместимости массива при определенном условие. Жесткая связь между оператором <i>return</i> и возвращаемым булевым значением true, говорит нам о том, что если возникнет исключительная ситуация, выполнение прервётся. Устойчивость метода оставляет желать лучшего.<br/>
<br/>
Вернемся опять к нашему исходному коду. И рассмотрим следующие строку кода:<br/>
<br/>
<pre><code class="java">
// Роль данного вызова метода будет определена далее в статье.
	IdCustomer.remove(2);
</code></pre> <br/>
Возникает вопрос, если взять в расчет авто упаковку, какой элемент удалится? По выводу на консоль мы ясно видим, что это будет <i>3</i>. Итак, что-то пошло не так. Исследуя класс <i>ArrayList</i>, в окне <b>Outline </b>обнаруживаем два одинаковых имени вызываемого метода.<br/>
<br/>
<img src="https://habrastorage.org/files/8b2/416/f83/8b2416f838d5467d982aabe0f7b4afd4.jpg"/><br/>
<br/>
Рассмотрим первый метод и определим его назначение:<br/>
<br/>
<pre><code class="java">
public E remove(int index) {
        rangeCheck(index);

        modCount++;
// Подготовка возврата удаляемого элемента.
        E oldValue = elementData(index);
// Вычисление размера для смещения
        int numMoved = size - index - 1;
        if (numMoved &gt; 0)
// Удаление(затирание) элемента.
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
        elementData[--size] = null;
// Возврат удалённого элемента.
        return oldValue;
    }</code></pre><br/>
Беглым анализом можно определить, что метод копирует одну часть относительно значения переменой <i>numMoved </i> одного и того же массива в другую позицию<i>(index+1, index)</i>. То есть затирание и есть удаление элемента массива по его индексу, при этом старое значение возвращается методом и метка конца <i>(null)</i> массива перезаписывается заново, относительно новых смещений. Определённо, в нашей программе вызывается именно данный метод и авто упаковка не происходит. В противном случае после авто упаковки удалился бы элемент <i>2</i>, а не элемент из массива на позиции <i>[2]</i>. Для ясности проверим код другой версии метода remove().<br/>
<br/>
<pre><code class="java">
public boolean remove(Object o) {

        if (o == null) {
// Поиск null-элемента
            for (int index = 0; index &lt; size; index++)
                if (elementData[index] == null) {
// Удаление найденного null-элемента
                    fastRemove(index);
// Возврат флага-успеха
                    return true;
                }
        } else {
// Поиск элемента
            for (int index = 0; index &lt; size; index++)
                if (o.equals(elementData[index])) {
// Удаление найденного элемента
                    fastRemove(index);
// Возврат флага-успеха
                    return true;
                }
        }
// Возврат флага-неудачи
        return false;
    }
</code></pre><br/>
 <br/>
Метод выполняет два основных действия.<br/>
<ul>
<li>1. Удаление null-элемента из массива.</li>
<li>2. Удаление элемента в соответствии с передаваемым аргументом.</li>
</ul><br/>
Используя цикл, метод последовательно <i>от 0 до size</i> перебирает все элементы массива. Признак соответствия элемента с передаваемым в аргументе устанавливается с помощью метода: <br/>
<br/>
<pre><code class="java">
// Сравнение полей вызывающего объекта с вызываемым.
o.equals(elementData[index])
</code></pre><br/>
Если соответствующий элемент будет обнаружен, он будет незамедлительно удален из массива. Для наглядности видоизменим строку удаления элемента, передав в качестве аргумента адрес на объект класс <i>Integer</i>:<br/>
<br/>
<pre><code class="java">
// IdCustomer.remove(2);
IdCustomer.remove(new Integer(2));
</code></pre> <br/>
<i><b>Вывод программы на консоль:</b><br/>
[1, 2, 3]<br/>
[1, 3]</i><br/>
<br/>
Предполагаю, что авто упаковка основана на приоритетных принципах, где удаление по индексу имеет более высокий приоритет.<br/>
<br/>
<div class="spoiler"><b class="spoiler_title">Функция native System.arraycopy()</b><div class="spoiler_text">Кстати, если посмотреть внимательно, то в обоих методах удаления элемента, используется <i>native </i>метод <i>System.arraycopy()</i>, очень быстро копирующий одну часть памяти в другую.<br/>
<br/>
<b>Java Native Interface.</b><br/>
Native methods-methods used by a Java program but written in a different language-have been in the JDK since the beginning. As promised, the native methods interface from 1.0 has been completely rewritten and formalized. This interface is now named the Java Native Interface, or JNI for short.</div></div> <br/>
Напоследок рассмотрим вывод коллекции на консоль. Для это мы используем обычный метод вывода с переводом строки:<br/>
<br/>
<pre><code class="java">
public void println(Object x) {
// Мост ведущий к toString()
        String s = String.valueOf(x);
        synchronized (this) {
// Печать строки
            print(s);
            newLine();
        }
    }
</code></pre> <br/>
<br/>
<pre><code class="java">
 public static String valueOf(Object obj) {
        return (obj == null) ? &quot;null&quot; : obj.toString();
    }
</code></pre> <br/>
Объект <i>IdCustomer</i> сам предоставляет строку в виде коллекции, для этого управление передаётся его внутреннему переопределенному методу <i>toString()</i>. Используя <i>Debug</i> мы можем сразу войти в тело метода или пойти другим путем и отыскать его в иерархии классов:<br/>
<br/>
<pre><code class="java">
public abstract class AbstractCollection&lt;E&gt; implements Collection&lt;E&gt; {
// ..........Методы............
// ..........Поля................
public String toString() {
        Iterator&lt;E&gt; it = iterator();
// Определение наполненности коллекции.
        if (! it.hasNext())
            return &quot;[]&quot;;
// Создание изменяемого массива.
        StringBuilder sb = new StringBuilder();
        sb.append('[');
        for (;;) {
// Получение следующего элемента коллекции.
            E e = it.next();
// Добавление элемента коллекции стокового представления в массив.
            sb.append(e == this ? &quot;(this Collection)&quot; : e);
            if (! it.hasNext())
// Возврат адреса объекта класса String, содержащий всю коллекцию элементов.
                return sb.append(']').toString();
            sb.append(',').append(' ');
        }
    }
// ..........Методы............
// ..........Поля................
}
</code></pre> <br/>
Проанализировав код, мы можем выделить три составные части. <br/>
<br/>
<ul>
<li>1. Определение наполненности массива;</li>
<li>2. Создание объекта класса <i>StringBuilder</i>, который позволяет изменять свой внутренний массив, в отличии, от класса <i>String</i>;</li>
<li>3. Добавление в массив значений объектов коллекции в виде стокового представления. </li>
</ul><br/>
После выполнения метода, сформируется объект класса <i>String</i>, ссылка на который будет передана через метод-мост прямиком в <i>println(Object x)</i>. Работа с классом ArrayList не ограничивается лишь методами, описанными выше. На сайте <a href="https://www.tutorialspoint.com/java/">Tutorials point</a> вы сможете найти другую дополнительную информацию по этой теме.



Статья 8


Справочник по Java Collections Framework




Данная публикация не является полным разбором или анализом (не покрывает пакет <code>java.util.concurrent</code>). Это, скорее, справочник, который поможет начинающим разработчикам понять ключевые отличия одних коллекций от других, а более опытным разработчикам просто освежить материал в памяти.<br/>
<br/>
<h4>Что такое Java Collections Framework?</h4><br/>
Java Collection Framework — иерархия интерфейсов и их реализаций, которая является частью JDK и позволяет разработчику пользоваться большим количесвом структур данных из «коробки».<br/>
<br/>
<h4>Базовые понятия</h4><br/>
На вершине иерархии в Java Collection Framework располагаются 2 интерфейса: <code>Collection</code> и <code>Map</code>. Эти интерфейсы разделяют все коллекции, входящие во фреймворк на две части по типу хранения данных: простые последовательные наборы элементов и наборы пар «ключ — значение» (словари).<br/>
<br/>
<img src="https://habrastorage.org/files/65c/d6d/ce5/65cd6dce50e84d659152c482e5565f3c.png" alt="image"/><br/>
<a name="habracut"></a><br/>
<b><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Collection.html">Collection</a></b> — этот интерфейс находится в составе JDK c версии 1.2 и определяет основные методы работы с простыми наборами элементов, которые будут общими для всех его реализаций (например <code>size()</code>, <code>isEmpty()</code>, <code>add(E e)</code> и др.). Интерфейс был слегка доработан с приходом дженериков в Java 1.5. Так же в версии Java 8 было добавлено несколько новых метода для работы с лямбдами (такие как <code>stream()</code>, <code>parallelStream()</code>, <code>removeIf(Predicate&lt;? super E&gt; filter)</code> и др.).<br/>
<br/>
Важно также отметить, что эти медоды были реализованы непосредственно в интерфейсе как <code>default</code>-медоды.<br/>
<br/>
<b><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Map.html">Map</a></b>. Данный интерфейс также находится в составе JDK c версии 1.2 и предоставляет разработчику базовые методы для работы с данными вида «ключ — значение».Также как и <code>Collection</code>, он был дополнен дженериками в версии Java 1.5 и в версии Java 8 появились дополнительные методы для работы с лямбдами, а также методы, которые зачастую реализовались в логике приложения (<code>getOrDefault(Object key, V defaultValue)</code>, <code>putIfAbsent(K key, V value)</code>).<br/>
<br/>
<h4>Интерфейс Map [<a href="http://docs.oracle.com/javase/8/docs/api/java/util/Map.html">doc</a>]</h4><br/>
<img src="https://habrastorage.org/files/40a/eca/09a/40aeca09ac1c4cc7bdbd475a3c12fd95.png"/><br/>
<br/>
<b><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Hashtable.html">Hashtable</a></b> — реализация такой структуры данных, как хэш-таблица. Она не позволяет использовать <code>null</code> в качестве значения или ключа. Эта коллекция была реализована раньше, чем Java Collection Framework, но в последствии была включена в его состав. Как и другие коллекции из Java 1.0, <code>Hashtable</code> является синхронизированной (почти все методы помечены как <code>synchronized</code>). Из-за этой особенности у неё имеются существенные проблемы с производительностью и, начиная с Java 1.2, в большинстве случаев рекомендуется использовать другие реализации интерфейса <code>Map</code> ввиду отсутствия у них синхронизации.<br/>
<br/>
<b><a href="http://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html">HashMap</a></b> — коллекция является альтернативой <code>Hashtable</code>. Двумя основными отличиями от <code>Hashtable</code> являются то, что <code>HashMap</code> не синхронизирована и <code>HashMap</code> позволяет использовать <code>null</code> как в качестве ключа, так и значения. Так же как и <code>Hashtable</code>, данная коллекция не является упорядоченной: порядок хранения элементов зависит от хэш-функции. Добавление элемента выполняется за константное время O(1), но время удаления, получения зависит от распределения хэш-функции. В идеале является константным, но может быть и линейным O(n). Более подробную информацию о <code>HashMap</code> можно почитать <a href="http://habrahabr.ru/post/128017/">здесь</a> (актуально для Java &lt; 8). <br/>
<br/>
<b><a href="http://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html">LinkedHashMap</a></b> — это упорядоченная реализация хэш-таблицы. Здесь, в отличии от <code>HashMap</code>, порядок итерирования равен порядку добавления элементов. Данная особенность достигается благодаря двунаправленным связям между элементами (аналогично <code>LinkedList</code>). Но это преимущество имеет также и недостаток — увеличение памяти, которое занимет коллекция. Более подробная информация изложена в этой <a href="http://habrahabr.ru/post/129037/">статье</a>.<br/>
<br/>
<b><a href="http://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html">TreeMap</a></b> — реализация <code>Map</code> основанная на красно-чёрных деревьях. Как и <code>LinkedHashMap</code> является упорядоченной. По-умолчанию, коллекция сортируется по ключам с использованием принципа &quot;<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html">natural ordering</a>&quot;, но это поведение может быть настроено под конкретную задачу при помощи объекта <code>Comparator</code>, которые указывается в качестве параметра при создании объекта <code>TreeMap</code>.<br/>
<br/>
<b><a href="http://docs.oracle.com/javase/8/docs/api/java/util/WeakHashMap.html">WeakHashMap</a></b> — реализация хэш-таблицы, которая организована с использованием <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/ref/WeakReference.html">weak references</a>. Другими словами, Garbage Collector автоматически удалит элемент из коллекции при следующей сборке мусора, если на ключ этого элеметна нет жёстких ссылок. <br/>
<br/>
<h4>Интерфейс List [<a href="http://docs.oracle.com/javase/8/docs/api/java/util/List.html">doc</a>]</h4><br/>
<img src="https://habrastorage.org/files/187/da1/649/187da164972c4519b6affbc4a2c6fda1.png"/><br/>
<br/>
Реализации этого интерфейса представляют собой упорядоченные коллекции. Кроме того, разработчику предоставляется возможность доступа к элементам коллекции по индексу и по значению (так как реализации позволяют хранить дубликаты, результатом поиска по значению будет первое найденное вхождение).<br/>
<br/>
<b><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Vector.html">Vector</a></b> — реализация динамического массива объектов. Позволяет хранить любые данные, включая null в качестве элемента. <code>Vector</code> появился в JDK версии Java 1.0, но как и <code>Hashtable</code>, эту коллекцию не рекомендуется использовать, если не требуется достижения потокобезопасности. Потому как в <code>Vector</code>, в отличии от других реализаций <code>List</code>, все операции с данными являются синхронизированными. В качестве альтернативы часто применяется аналог — <code>ArrayList</code>.<br/>
<br/>
<b><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Stack.html">Stack</a></b> — данная коллекция является расширением коллекции <code>Vector</code>. Была добавлена в Java 1.0 как реализация стека LIFO (last-in-first-out). Является частично синхронизированной коллекцией (кроме метода добавления <code>push()</code>). После добавления в Java 1.6 интерфейса <code>Deque</code>, рекомендуется использовать именно реализации этого интерфейса, например <code>ArrayDeque</code>.<br/>
<br/>
<b><a href="http://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html">ArrayList</a></b> — как и <code>Vector </code> является реализацией динамического массива объектов. Позволяет хранить любые данные, включая null в качестве элемента. Как можно догадаться из названия, его реализация основана на обычном массиве. Данную реализацию следует применять, если в процессе работы с коллекцией предплагается частое обращение к элементам по индексу. Из-за особенностей реализации поиндексное обращение к элементам выполняется за константное время O(1). Но данную коллекцию рекомендуется избегать, если требуется частое удаление/добавление элементов в середину коллекции. Подробный анализ и описание можно почитать в <a href="http://habrahabr.ru/post/128269/">этом</a> хабратопике.<br/>
<br/>
<b><a href="http://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html">LinkedList</a></b> — ещё одина реализация <code>List</code>. Позволяет хранить любые данные, включая <code>null</code>. Особенностью реализации данной коллекции является то, что в её основе лежит двунаправленный связный список (каждый элемент имеет ссылку на предыдущий и следующий). Благодаря этому, добавление и удаление из середины, доступ по индексу, значению происходит за линейное время O(n), а из начала и конца за константное O(1). Так же, ввиду реализации, данную коллекцию можно использовать как стек или очередь. Для этого в ней реализованы соответсвующие методы. На Хабре также есть <a href="http://habrahabr.ru/post/127864/">статья </a>с подробным анализом и описанием этой коллекции.<br/>
<br/>
<h4>Интерфейс Set [<a href="http://docs.oracle.com/javase/8/docs/api/java/util/Set.html">doc</a>]</h4><br/>
<img src="https://habrastorage.org/files/aca/208/428/aca20842816a48628772bd23d2bb0f24.png"/><br/>
<br/>
Представляет собой неупорядоченную коллекцию, которая не может содержать дублирующиеся данные. Является программной моделью математического понятия «множество». <br/>
<br/>
<b><a href="http://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html">HashSet</a></b> — реализация интерфейса <code>Set</code>, базирующаяся на <code>HashMap</code>. Внутри использует объект HashMap для хранения данных. В качестве ключа используется добавляемый элемент, а в качестве значения — объект-пустышка (new Object()). Из-за особенностей реализации порядок элементов не гарантируется при добавлении.<br/>
<br/>
<b><a href="http://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashSet.html">LinkedHashSet</a></b> — отличается от <code>HashSet</code> только тем, что в основе лежит <code>LinkedHashMap</code> вместо <code>HashSet</code>. Благодаря этому отличию порядок элементов при обходе коллекции является идентичным порядку добавления элементов.<br/>
<br/>
<b><a href="http://docs.oracle.com/javase/8/docs/api/java/util/TreeSet.html">TreeSet</a></b> — аналогично другим классам-реализациям интерфейса <code>Set</code> содержит в себе объект <code>NavigableMap</code>, что и обуславливает его поведение. Предоставляет возможность управлять порядком элементов в коллекции при помощи объекта <code>Comparator</code>, либо сохраняет элементы с использованием &quot;<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html">natural ordering</a>&quot;.<br/>
<br/>
<h4>Интерфейс Queue [<a href="http://docs.oracle.com/javase/8/docs/api/java/util/Set.html">doc</a>]</h4><br/>
<img src="https://habrastorage.org/files/3ee/116/dc0/3ee116dc0d6e4775a72187f551001869.png"/><br/>
<br/>
Этот интерфейс описывает коллекции с предопределённым способом вставки и извлечения элементов, а именно — очереди FIFO (first-in-first-out). Помимо методов, определённых в интерфейсе Collection, определяет дополнительные методы для извлечения и добавления элементов в очередь. Большинство реализаций данного интерфейса находится в пакете <code>java.util.concurrent</code> и подробно рассматриваются в <a href="http://habrahabr.ru/company/luxoft/blog/157273/">данном</a> обзоре.<br/>
<br/>
<b><a href="http://docs.oracle.com/javase/8/docs/api/java/util/PriorityQueue.html">PriorityQueue</a></b> — является единственной прямой реализацией интерфейса <code>Queue</code> (была добавлена, как и интерфейс Queue, в Java 1.5), не считая класса <code>LinkedList</code>, который так же реализует этот интерфейс, но был реализован намного раньше. Особенностью данной очереди является возможность управления порядком элементов. По-умолчанию, элементы сортируются с использованием «natural ordering», но это поведение может быть переопределено при помощи объекта <code>Comparator</code>, который задаётся при создании очереди. Данная коллекция не поддерживает <code>null</code> в качестве элементов.<br/>
<br/>
<b><a href="http://docs.oracle.com/javase/8/docs/api/java/util/ArrayDeque.html">ArrayDeque</a></b> — реализация интерфейса <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Deque.html">Deque</a>, который расширяет интерфейс <code>Queue</code> методами, позволяющими реализовать конструкцию вида LIFO (last-in-first-out). Интерфейс <code>Deque </code>и реализация <code>ArrayDeque </code>были добавлены в Java 1.6. Эта коллекция представляет собой реализацию с использованием массивов, подобно <code>ArrayList</code>, но не позволяет обращаться к элементам по индексу и хранение <code>null</code>. Как заявлено в документации, коллекция работает быстрее чем <code>Stack</code>, если используется как LIFO коллекция, а также быстрее чем LinkedList, если используется как FIFO.<br/>
<br/>
<h4>Заключение</h4><br/>
Java Collections Framework содержит большое количество различных структур данных, доступных в JDK «из коробки», которые в большинстве случаев покрывают все потребности при реализации логики приложения. Сравнение временных характеристик основных коллекций, которые зачастую используются в разработке приложений приведено в таблице:<br/>
<br/>
<img src="https://habrastorage.org/files/364/d7e/419/364d7e41907e453b8e60128cdac459dc.png"/><br/>
<br/>
При необходимости, разработчик может создать собственную реализацию, расширив или переопределив существующую логику, либо создав свою собственную реализацию подходящего интерфейса с нуля. Также существует некоторое количество готовых решений, которые являются альтернативой или дополнением к Java Collections Framework. Наиболее популярными являются <a href="https://code.google.com/p/guava-libraries/">Google Guava</a> и <a href="http://commons.apache.org/proper/commons-collections/">Commons Collections</a>.<br/>
<br/>
В дополнение, хотелось бы указать в качестве дополнительного материала, <a href="http://habrahabr.ru/company/luxoft/blog/157273/">ссылку</a> на обзор пакета <code>java.util.concurrent</code>. Который является отличным дополнением к изложенному материалу.




Статья 9

Обзор java.util.concurrent.*

В повседневной работе не так уж часто приходится сталкиваться с пакетом для многопоточности java.util.concurrent. Иногда существуют проектные ограничения по использованию java 1.4.2, где нет данного пакета, но чаще всего хватает обычной синхронизации и не требуется ничего сверхъестественного. К счастью, периодически возникают задачи, заставляющие немного пораскинуть мозгами и либо написать велосипед, либо порыться в javadoc'ах и найти что-то более подходящее. С велосипедом проблем нет — просто берешь и пишешь, благо ничего суперсложного в многопоточности нет. С другой стороны, меньше кода — меньше багов. Тем более, что на многопоточность никто в здравом уме юнит тестов не пишет, т.к. это уже полноценные интеграционные тесты получаются со всеми вытекающими последствиями.<br/>
<br/>
Что выбрать для конкретного случая? В условиях запарки и deadline'ов довольно сложно охватить весь java.util.concurrent. Выбирается что то похожее и вперед! Так, постепенно, в коде появляются ArrayBlockingQueue, ConcurrentHashMap, AtomicInteger, Collections.synchronizedList(new LinkedList()) и другие интересности. Иногда правильно, иногда нет. В какой то момент времени начинаешь осознавать, что более 95% стандартных классов в java вообще не используются при разработке продукта. Коллекции, примитивы, перекладывание байтиков с одного места на другое, hibernate, spring или EJB, еще какая то библиотека и, вуаля, приложение готово.<br/>
<br/>
Чтобы хоть как то упорядочить знания и облегчить вхождение в тему, ниже идет обзор классов для работы с многопоточностью. Пишу прежде всего как шпаргалку для себя. А если еще кому сгодится — вообще замечательно. <a name="habracut"></a><br/>
<br/>
<h1>Для затравки</h1><br/>
Сразу приведу пару интересных ссылок. Первая для тех, кто немного плавает в многопоточности. Вторая для «продвинутых» программеров — возможно тут найдётся что-нибудь полезное.<br/>
<ul>
<li><a href="http://docs.oracle.com/javase/tutorial/essential/concurrency/index.html">Java Concurrency Tutorials</a></li>
<li><a href="http://www.cs.umd.edu/class/fall2002/cmsc433-0201/lectures/cpjslides.pdf">Concurrent Programming in Java by Doug Lea</a></li>
</ul><br/>
<br/>
<h1>Немного об авторе пакета java.util.concurrent</h1><br/>
Если кто хоть когда-нибудь открывал исходники классов java.util.concurrent, не могли не заметить в авторах Doug Lea (Даг Ли), профессора Oswego (Осуиго) университета штата Нью Йорк. В список наиболее известных его разработок попали java <a href="http://gee.cs.oswego.edu/dl/classes/collections/index.html">collections</a> и <a href="http://gee.cs.oswego.edu/dl/classes/EDU/oswego/cs/dl/util/concurrent/intro.html">util.concurrent</a>, которые в том или ином виде отразились в существующих JDK. Также им была написана <a href="http://en.wikipedia.org/wiki/Malloc#dlmalloc">dlmalloc</a> имплементация для динамического выделения памяти. Среди литературы отметилась книга по многопоточности <a href="http://www.informit.com/store/concurrent-programming-in-java-design-principles-and-9780201310092">Concurrent Programming in Java: Design Principles and Pattern, 2nd Edition</a>. Более подробно можно ознакомиться на его <a href="http://g.oswego.edu/">домашней страничке</a>.<br/>
<br/>
<img src="https://habrastorage.org/storage2/57d/237/064/57d2370647eb56837d5652db3eecd406.jpg"/><br/>
Выступление Doug Lea на <a href="http://wiki.jvmlangsummit.com/2010_Main_Page">JVM Language Summit</a> в 2010 году.<br/>
<br/>
<h1>По вершкам</h1><br/>
Наверное у многих возникало чувство некоторого хаоса при беглом взгляде на java.util.concurrent. В одном пакете намешаны разные классы с совершенно разным функционалом, что несколько затрудняет понимание что к чему относится и как это работает. Поэтому, можно схематично поделить классы и интерфейсы по функциональному признаку, а затем пробежаться по реализации конкретных частей.<br/>
<br/>
<img src="https://habrastorage.org/storage2/ff8/e9d/719/ff8e9d719402e1b164febae3fd8c0ff5.png"/><br/>
<br/>
<b>Concurrent Collections</b> — набор коллекций, более эффективно работающие в многопоточной среде нежели стандартные универсальные коллекции из java.util пакета. Вместо базового враппера Collections.synchronizedList с блокированием доступа ко всей коллекции используются блокировки по сегментам данных или же оптимизируется работа для параллельного чтения данных по <a href="http://ru.wikipedia.org/wiki/%D0%9D%D0%B5%D0%B1%D0%BB%D0%BE%D0%BA%D0%B8%D1%80%D1%83%D1%8E%D1%89%D0%B0%D1%8F_%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F">wait-free</a> алгоритмам.<br/>
<br/>
<b>Queues</b> — неблокирующие и блокирующие очереди с поддержкой многопоточности. Неблокирующие очереди заточены на скорость и работу без блокирования потоков. Блокирующие очереди используются, когда нужно «притормозить» потоки «Producer» или «Consumer», если не выполнены какие-либо условия, например, очередь пуста или перепонена, или же нет свободного «Consumer»'a.<br/>
<br/>
<b>Synchronizers</b> — вспомогательные утилиты для синхронизации потоков. Представляют собой мощное оружие в «параллельных» вычислениях.<br/>
<br/>
<b>Executors</b> — содержит в себе отличные фрейморки для создания пулов потоков, планирования работы асинхронных задач с получением результатов. <br/>
<br/>
<b>Locks</b> — представляет собой альтернативные и более гибкие механизмы синхронизации потоков по сравнению с базовыми synchronized, wait, notify, notifyAll.<br/>
<br/>
<b>Atomics</b> — классы с поддержкой атомарных операций над примитивами и ссылками.<br/>
<br/>
<br/>
<br/>
<h1>1. Concurrent Collections</h1><br/>
<br/>
<h4>CopyOnWrite коллекции</h4><br/>
<img src="https://habrastorage.org/storage2/324/0ee/2cf/3240ee2cf87d7582e7d721ee7e0be951.png"/><br/>
<br/>
Название говорит само за себя. Все операции по изменению коллекции (add, set, remove) приводят к созданию новой копии внутреннего массива. Тем самым гарантируется, что при проходе итератором по коллекции не кинется ConcurrentModificationException. Следует помнить, что при копировании массива копируются только референсы (ссылки) на объекты (shallow copy), т.ч. доступ к полям элементов не thread-safe. CopyOnWrite коллекции удобно использовать, когда write операции довольно редки, например при реализации механизма подписки listeners и прохода по ним.<br/>
<br/>
<b>CopyOnWriteArrayList&lt;E&gt; <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — Потокобезопасный аналог ArrayList, реализованный с CopyOnWrite алгоритмом. <div class="spoiler"><b class="spoiler_title">Дополнительные методы и конструктор</b><div class="spoiler_text"><table>
<tr>
<td>CopyOnWriteArrayList(E[] toCopyIn)</td>
<td>Конструктор, принимающий на вход массив.</td>
</tr>
<tr>
<td>int indexOf(E e, int index)</td>
<td>Возвращает индекс первого найденного элемента, начиная поиск с заданного индекса.</td>
</tr>
<tr>
<td>int lastIndexOf(E e, int index)</td>
<td>Возвращает индекс первого найденного элемента при обратном поиске, начиная с заданного индекса.</td>
</tr>
<tr>
<td>boolean addIfAbsent(E e)</td>
<td>Добавить элемент, если его нет в коллекции. Для сравнения элементов используется метод equals.</td>
</tr>
<tr>
<td>int addAllAbsent(Collection&lt;? extends E&gt; c)</td>
<td>Добавить элементы, если они отсутствуют в коллекции. Возвращает количество добавленных элементов.</td>
</tr>
</table></div></div><br/>
<b>CopyOnWriteArraySet&lt;E&gt; <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — Имплементация интерфейса Set, использующая за основу CopyOnWriteArrayList. В отличии от CopyOnWriteArrayList, дополнительных методов нет.<br/>
<br/>
<h4>Scalable Maps</h4><br/>
<img src="https://habrastorage.org/storage2/5b8/765/fe7/5b8765fe74c096ef78942ba450b82765.png"/><br/>
<br/>
Улучшенные реализации HashMap, TreeMap с лучшей поддержкой многопоточности и масштабируемости.<br/>
<br/>
<b>ConcurrentMap&lt;K, V&gt; <img src="https://habrastorage.org/storage2/36b/c31/fa2/36bc31fa2bdf7a08f3a85dff79ee4eef.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — Интерфейс, расширяющий Map несколькими дополнительными атомарными операциями.<br/>
<div class="spoiler"><b class="spoiler_title">Дополнительные методы</b><div class="spoiler_text"><table>
<tr>
<td>V putIfAbsent(K key, V value)</td>
<td>Добавляет новую пару key-value только в том случае, если ключа нет в коллекции. Возвращает предыдущее значение для заданного ключа.</td>
</tr>
<tr>
<td>boolean remove(Object key, Object value)</td>
<td>Удаляет key-value пару только если заданному ключу соответствует заданное значение в Map. Возвращает true, если элемент был успешно удален.</td>
</tr>
<tr>
<td>boolean replace(K key, V oldValue, V newValue)</td>
<td>Заменяет старое значение на новое по ключу только если старое значение соответствует заданному значению в Map. Возвращает true, если значение было заменено на новое.</td>
</tr>
<tr>
<td>V replace(K key, V value)</td>
<td>Заменяет старое значение на новое по ключу только если ключ ассоциирован с любым значением. Возвращает предыдущее значение для заданного ключа.</td>
</tr>
</table></div></div><br/>
<b>ConcurrentHashMap&lt;K, V&gt; <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — В отличие от Hashtable и блоков synhronized на HashMap, данные представлены в виде сегментов, разбитых по hash'ам ключей. В результате, для доступ к данным лочится по сегментам, а не по одному объекту. В дополнение, итераторы представляют данные на определенный срез времени и не кидают ConcurrentModificationException. Более детально ConcurrentHashMap описан в хабратопике <a href="http://habrahabr.ru/post/132884/">тут</a>. <div class="spoiler"><b class="spoiler_title">Дополнительный конструктор</b><div class="spoiler_text"><table>
<tr>
<td>ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)</td>
<td>3-й параметр конструктора — ожидаемое количество одновременно пишущих потоков. Значение по умолчанию 16. Влияет на размер коллекции в памяти и производительность.</td>
</tr>
</table></div></div><br/>
<b>ConcurrentNavigableMap&lt;K,V&gt; <img src="https://habrastorage.org/storage2/36b/c31/fa2/36bc31fa2bdf7a08f3a85dff79ee4eef.png"/> <img src="https://habrastorage.org/storage2/c29/5ad/47f/c295ad47f86291abd7e8fe2b91b9621c.png"/></b> — Расширяет интерфейс NavigableMap и вынуждает использовать ConcurrentNavigableMap объекты в качестве возвращаемых значений. Все итераторы декларируются как безопасные к использованию и не кидают ConcurrentModificationException.<br/>
<br/>
<b>ConcurrentSkipListMap&lt;K, V&gt; <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/c29/5ad/47f/c295ad47f86291abd7e8fe2b91b9621c.png"/></b> — Является аналогом TreeMap с поддержкой многопоточности. Данные также сортируются по ключу и гарантируется усредненная производительность log(N) для containsKey, get, put, remove и других похожих операций. Алгоритм работы SkipList описан на <a href="http://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D1%81_%D0%BF%D1%80%D0%BE%D0%BF%D1%83%D1%81%D0%BA%D0%B0%D0%BC%D0%B8">Wiki</a> и <a href="http://habrahabr.ru/post/139870/">хабре</a>.<br/>
<br/>
<b>ConcurrentSkipListSet&lt;E&gt; <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/c29/5ad/47f/c295ad47f86291abd7e8fe2b91b9621c.png"/></b> — Имплементация Set интерфейса, выполненная на основе ConcurrentSkipListMap.<br/>
<br/>
<br/>
<br/>
<h1>2. Queues</h1><br/>
<h4>Non-Blocking Queues</h4><br/>
<img src="https://habrastorage.org/storage2/bc7/78f/458/bc778f4581a3bd53e28ab87c0ca1a0ed.png"/><br/>
<br/>
Потокобезопасные и неблокирующие имплементации Queue на связанных нодах (linked nodes). <br/>
<br/>
<b>ConcurrentLinkedQueue&lt;E&gt; <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — В имплементации используется wait-free алгоритм от Michael & Scott, адаптированный для работы с garbage collector'ом. Этот алгоритм довольно эффективен и, что самое важное, очень быстр, т.к. построен на <a href="http://en.wikipedia.org/wiki/Compare-and-swap">CAS</a>. Метод size() может работать долго, т.ч. лучше постоянно его не дергать. Детальное описание алгоритма можно посмотреть тут <a href="http://www.cs.rochester.edu/u/michael/PODC96.html">тут</a>.<br/>
<br/>
<b>ConcurrentLinkedDeque&lt;E&gt; <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/968/b76/9b1/968b769b1a83359a83e5fd169d8dbde4.png"/></b> — Deque расшифровывается как Double ended queue и читается как «Deck». Это означает, что данные можно добавлять и вытаскивать с обоих сторон. Соответственно, класс поддерживает оба режима работы: FIFO (First In First Out) и LIFO (Last In First Out). На практике, ConcurrentLinkedDeque стоит использовать только, если обязательно нужно LIFO, т.к. за счет двунаправленности нод данный класс проигрывает по производительности на 40% по сравнению с ConcurrentLinkedQueue.<br/>
<br/>
<h4>Blocking Queues</h4><br/>
<img src="https://habrastorage.org/storage2/009/d00/33b/009d0033b5c6bf14fa31d66cf7ea1980.png"/><br/>
<br/>
<b>BlockingQueue&lt;E&gt; <img src="https://habrastorage.org/storage2/36b/c31/fa2/36bc31fa2bdf7a08f3a85dff79ee4eef.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — При обработке больших потоков данных через очереди становится явно недостаточно использования ConcurrentLinkedQueue. Если потоки, разгребающие очередь перестанут справляться с наплывом данных, то можно довольно быстро схлопотать out of memory или перегрузить IO/Net настолько, что производительность упадет в разы пока не настанет отказ системы по таймаутам или из за отсутствия свободных дескрипторов в системе. Для таких случаев нужна queue с возможностью задать размер очереди или с блокировками по условиям. Тут то и появляется интерфейс BlockingQueue, открывающий дорогу к целому набору полезных классов. Помимо возможности задавать размер queue, добавились новые методы, которые реагируют по-разному на незаполнение или переполнение queue. Так, например, при добавлении элемента в переполненную queue, один метод кинет IllegalStateException, другой вернет false, третий заблокирует поток, пока не появится место, четвертый же заблокирует поток с таймаутом и вернет false, если место так и не появится. Также стоит отметить, что блокирующие очереди не поддерживают null значения, т.к. это значение используется в методе poll как индикатор таймаута. <br/>
<br/>
<b>ArrayBlockingQueue&lt;E&gt; <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — Класс блокирующей очереди, построенный на классическом кольцевом буфере. Помимо размера очереди, доступна возможность управлять «честностью» блокировок. Если fair=false (по умолчанию), то очередность работы потоков не гарантируется. Более подробно о «честности» можно посмотреть в описании ReentrantLock'a.<br/>
<br/>
<b>DelayQueue&lt;E extends Delayed&gt; <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — Довольно специфичный класс, который позволяет вытаскивать элементы из очереди только по прошествии некоторой задержки, определенной в каждом элементе через метод getDelay интерфейса Delayed.<br/>
<br/>
<b>LinkedBlockingQueue&lt;E&gt; <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — Блокирующая очередь на связанных нодах, реализованная на «two lock queue» алгоритме: один лок на добавление, другой на вытаскивание элемента. За счет двух локов, по сравнению с ArrayBlockingQueue, данный класс показывает более высокую производительность, но и расход памяти у него выше. Размер очереди задается через конструктор и по умолчанию равен Integer.MAX_VALUE.<br/>
<br/>
<b>PriorityBlockingQueue&lt;E&gt; <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — Является многопоточной оберткой над PriorityQueue. При вставлении элемента в очередь, его порядок определяется в соответствии с логикой Comparator'а или имплементации Comparable интерфейса у элементов. Первым из очереди выходит самый наименьший элемент.<br/>
<br/>
<b>SynchronousQueue&lt;E&gt; <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — Эта очередь работает по принципу один вошел, один вышел. Каждая операция вставки блокирует «Producer» поток до тех пор, пока «Consumer» поток не вытащит элемент из очереди и наоборот, «Consumer» будет ждать пока «Producer» не вставит элемент.<br/>
<br/>
<b>BlockingDeque&lt;E&gt; <img src="https://habrastorage.org/storage2/36b/c31/fa2/36bc31fa2bdf7a08f3a85dff79ee4eef.png"/> <img src="https://habrastorage.org/storage2/c29/5ad/47f/c295ad47f86291abd7e8fe2b91b9621c.png"/></b> — Интерфейс, описывающий дополнительные методы для двунаправленной блокирующей очереди. Данные можно вставлять и вытаскивать с двух сторон очереди.<br/>
<br/>
<b>LinkedBlockingDeque&lt;E&gt; <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/c29/5ad/47f/c295ad47f86291abd7e8fe2b91b9621c.png"/></b> — Двунаправленная блокирующая очередь на связанных нодах, реализованная как простой двунаправленный список с одним локом. Размер очереди задается через конструктор и по умолчанию равен Integer.MAX_VALUE.<br/>
<br/>
<b> TransferQueue&lt;E&gt; <img src="https://habrastorage.org/storage2/36b/c31/fa2/36bc31fa2bdf7a08f3a85dff79ee4eef.png"/> <img src="https://habrastorage.org/storage2/968/b76/9b1/968b769b1a83359a83e5fd169d8dbde4.png"/></b> — Данный интерфейс может быть интересен тем, что при добавлении элемента в очередь существует возможность заблокировать вставляющий «Producer» поток до тех пор, пока другой поток «Consumer» не вытащит элемент из очереди. Блокировка может быть как с таймаутом, так и вовсе может быть заменена проверкой на наличие ожидающих «Consumer»ов. Тем самым появляется возможность реализации механизма передачи сообщений с поддержкой как синхронных, так и асинхронных сообщений.<br/>
<br/>
<b> LinkedTransferQueue&lt;E&gt; <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/968/b76/9b1/968b769b1a83359a83e5fd169d8dbde4.png"/></b> — Реализация TransferQueue на основе алгоритма Dual Queues with Slack. Активно использует <a href="http://en.wikipedia.org/wiki/Compare-and-swap">CAS</a> и <a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/misc/Unsafe.java#Unsafe.park%28boolean%2Clong%29">парковку</a> потоков, когда они находятся в режиме ожидания.<br/>
<br/>
<br/>
<br/>
<h1>3. Synchronizers</h1><br/>
<img src="https://habrastorage.org/storage2/632/495/7bd/6324957bdddacafa30f5751a27db917c.png"/><br/>
<br/>
В данном разделе представлены классы для активного управления потоков.<br/>
<br/>
<b> Semaphore <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — <a href="http://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D0%BC%D0%B0%D1%84%D0%BE%D1%80_(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)">Семафоры</a> чаще всего используются для ограничения количества потоков при работе с аппаратными ресурсами или файловой системой. Доступ к общему ресурсу управляется с помощью счетчика. Если он больше нуля, то доступ разрешается, а значение счетчика уменьшается. Если счетчик равен нулю, то текущий поток блокируется, пока другой поток не освободит ресурс. Количество разрешений и «честность» освобождения потоков задается через конструктор. Узким местом при использовании семафоров является задание количества разрешений, т.к. зачастую это число приходится подбирать в зависимости от мощности «железа».<br/>
<br/>
<b> CountDownLatch <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — Позволяет одному или нескольким потокам ожидать до тех пор, пока не завершится определенное количество операций, выполняющих в других потоках. Классический пример с драйвером довольно неплохо описывает логику класса: Потоки, вызывающие драйвер, будут висеть в методе await (с таймаутом или без), пока поток с драйвером не выполнит инициализацию с последующим вызовом метода countDown. Этот метод уменьшает счетчик count down на единицу. Как только счетчик становится равным нулю, все ожидающие потоки в await продолжат свою работу, а все последующие вызовы await будут проходить без ожиданий. Счетчик count down одноразовый и не может быть сброшен в первоначальное состояние.<br/>
<br/>
<b> CyclicBarrier <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — Может использоваться для синхронизации заданного количества потоков в одной точке. Барьер достигается когда N-потоков вызовут метод await(...) и заблокируются. После чего счетчик сбрасывается в исходное значение, а ожидающие потоки освобождаются. Дополнительно, если нужно, существует возможность запуска специального кода до разблокировки потоков и сброса счетчика. Для этого через конструктор передается объект с реализацией Runnable интерфейса.<br/>
<br/>
<b> Exchanger&lt;V&gt; <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — Как видно из названия, основное предназначение данного класса — это обмен объектами между двумя потоками. При этом, также поддерживаются null значения, что позволяет использовать данный класс для передачи только одного объекта или же просто как синхронизатор двух потоков. Первый поток, который вызывает метод exchange(...) заблокируется до тех пор, пока тот же метод не вызовет второй поток. Как только это произойдет, потоки обменяются значениями и продолжат свою работу.<br/>
<br/>
<b> Phaser <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/968/b76/9b1/968b769b1a83359a83e5fd169d8dbde4.png"/></b> — Улучшенная реализация барьера для синхронизации потоков, которая совмещает в себе функционал CyclicBarrier и CountDownLatch, вбирая в себя самое лучшее из них. Так, количество потоков жестко не задано и может динамически меняться. Класс может повторно переиспользоваться и сообщать о готовности потока без его блокировки. Более подробно можно почитать в хабратопике <a href="http://habrahabr.ru/post/117185/">тут</a>.<br/>
<br/>
<br/>
<br/>
<h1>4. Executors</h1><br/>
Вот мы и подобрались к самой большой части пакета. Здесь будут описаны интерфейсы для запуска асинхронных задач с возможностью получения результатов через Future и Callable интерфейсы, а также сервисы и фабрики для создания thread pools: ThreadPoolExecutor, ScheduledPoolExecutor, ForkJoinPool. Для лучшего понимания, сделаем небольшую декомпозицию интерфейсов и классов.<br/>
<br/>
<h4>Future and Callable</h4><br/>
<img src="https://habrastorage.org/storage2/b68/d1c/1d0/b68d1c1d05c8ae15bcc8bb3d5ca09bc9.png"/><br/>
<br/>
<b> Future&lt;V&gt; <img src="https://habrastorage.org/storage2/36b/c31/fa2/36bc31fa2bdf7a08f3a85dff79ee4eef.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — Замечательный интерфейс для получения результатов работы асинхронной операции. Ключевым методом здесь является метод get, который блокирует текущий поток (с таймаутом или без) до завершения работы асинхронной операции в другом потоке. Также, дополнительно существуют методы для отмены операции и проверки текущего статуса. В качестве имплементации часто используется класс FutureTask.<br/>
<br/>
<b> RunnableFuture&lt;V&gt; <img src="https://habrastorage.org/storage2/36b/c31/fa2/36bc31fa2bdf7a08f3a85dff79ee4eef.png"/> <img src="https://habrastorage.org/storage2/c29/5ad/47f/c295ad47f86291abd7e8fe2b91b9621c.png"/></b> — Если Future — это интерфейс для Client API, то интерфейс RunnableFuture уже используется для запуска асинхронной части. Успешное завершение метода run() завершает асинхронную операцию и позволяет вытаскивать результаты через метод get.<br/>
<br/>
<b> Callable&lt;V&gt; <img src="https://habrastorage.org/storage2/36b/c31/fa2/36bc31fa2bdf7a08f3a85dff79ee4eef.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — Расширенный аналог интерфейса Runnable для асинхронных операций. Позволяет возвращать типизированное значение и кидать checked exception. Несмотря на то, что в этом интерфейсе отсутсвует метод run(), многие классы java.util.concurrent поддерживают его наряду с Runnable.<br/>
<br/>
<b> FutureTask&lt;V&gt; <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — Имплементация интерфейса Future/RunnableFuture. Асинхронная операция принимается на вход одного из конструкторов в виде Runnable или Callable объектов. Сам же класс FutureTask предназначен для запуска в worker потоке, например через new Thread(task).start(), или через ThreadPoolExecutor. Результаты работы асинхронной операции вытаскиваются через метод get(...).<br/>
<br/>
<b> Delayed <img src="https://habrastorage.org/storage2/36b/c31/fa2/36bc31fa2bdf7a08f3a85dff79ee4eef.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — Используется для асинхронных задач, которые должны начаться в будущем, а также в DelayQueue. Позволяет задавать время до начала асинхронной операции.<br/>
<br/>
<b> ScheduledFuture&lt;V&gt; <img src="https://habrastorage.org/storage2/36b/c31/fa2/36bc31fa2bdf7a08f3a85dff79ee4eef.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — Маркерный интерфейс, объединяющий Future и Delayed интерфейсы.<br/>
<br/>
<b> RunnableScheduledFuture&lt;V&gt; <img src="https://habrastorage.org/storage2/36b/c31/fa2/36bc31fa2bdf7a08f3a85dff79ee4eef.png"/> <img src="https://habrastorage.org/storage2/c29/5ad/47f/c295ad47f86291abd7e8fe2b91b9621c.png"/></b> — Интерфейс, объединяющий RunnableFuture и ScheduledFuture. Дополнительно можно указывать является ли задача одноразовой или же должна запускаться с заданной периодичностью.<br/>
<br/>
<h4>Executor Services</h4><br/>
<img src="https://habrastorage.org/storage2/e0c/38d/f25/e0c38df25d2fd1d705976554c6452cb4.png"/><br/>
<br/>
<b> Executor <img src="https://habrastorage.org/storage2/36b/c31/fa2/36bc31fa2bdf7a08f3a85dff79ee4eef.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — Представляет собой базовый интерфейс для классов, реализующих запуск Runnable задач. Тем самым обеспечивается развязка между добавлением задачи и способом её запуска.<br/>
<br/>
<b> ExecutorService <img src="https://habrastorage.org/storage2/36b/c31/fa2/36bc31fa2bdf7a08f3a85dff79ee4eef.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — Интерфейс, который описывает сервис для запуска Runnable или Callable задач. Методы submit на вход принимают задачу в виде Callable или Runnable, а в качестве возвращаемого значения идет Future, через который можно получить результат. Методы invokeAll работают со списками задач с блокировкой потока до завершения всех задач в переданном списке или до истечения заданного таймаута. Методы invokeAny блокируют вызывающий поток до завершения любой из переданных задач. В дополнении ко всему, интерфейс содержит методы для graceful shutdown. После вызова метода shutdown, данный сервис больше не будет принимать задачи, кидая RejectedExecutionException при попытке закинуть задачу в сервис.<br/>
<br/>
<b> ScheduledExecutorService <img src="https://habrastorage.org/storage2/36b/c31/fa2/36bc31fa2bdf7a08f3a85dff79ee4eef.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — В дополнении к методам ExecutorService, данный интерфейс добавляет возможность запускать отложенные задачи.<br/>
<br/>
<b> AbstractExecutorService <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/93e/530/ead/93e530ead57ae1e70e6d067602e05095.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — Абстрактный класс для построения ExecutorService'a. Имплементация содержит базовую имплементацию методов submit, invokeAll, invokeAny. От этого класса наследуются ThreadPoolExecutor, ScheduledThreadPoolExecutor и ForkJoinPool.<br/>
<br/>
<h4>ThreadPoolExecutor & Factory</h4><br/>
<img src="https://habrastorage.org/storage2/125/385/1e3/1253851e3b0952109c8282990ad9dbab.png"/><br/>
<br/>
<b> Executors <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/d73/576/c72/d73576c72fd0c51fe4fffbda47fd2791.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — Класс-фабрика для создания ThreadPoolExecutor, ScheduledThreadPoolExecutor. Если нужно создать один из этих пулов, эта фабрика именно то, что нужно. Также, тут содержатся разные адаптеры Runnable-Callable, PrivilegedAction-Callable, PrivilegedExceptionAction-Callable и другие.<br/>
<br/>
<b> ThreadPoolExecutor <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — Очень мощный и важный класс. Используется для запуска асинхронных задач в пуле потоков. Тем самым практически полностью отсутствует оверхэд на поднятие и остановку потоков. А за счет фиксируемого максимума потоков в пуле обеспечивается прогнозируемая производительность приложения. Как было ранее сказано, создавать данный пул предпочтительно через один из методов фабрики Executors. Если же стандартных конфигураций будет недостаточно, то через конструкторы или сеттеры можно задать все основые параметры пула. Более подробно можно ознакомиться в этом <a href="http://habrahabr.ru/post/116363/">топике</a>.<br/>
<br/>
<b> ScheduledThreadPoolExecutor <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — В дополнении к методам ThreadPoolExecutor, позволяет запускать задачи после определенной задержки, а также с некоторой периодичностью, что позволяет реализовать на базе этого класса Timer Service.<br/>
<br/>
<b> ThreadFactory <img src="https://habrastorage.org/storage2/36b/c31/fa2/36bc31fa2bdf7a08f3a85dff79ee4eef.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — По умолчанию, ThreadPoolExecutor использует стандартную фабрику потоков, получаемую через Executors.defaultThreadFactory(). Если нужно что-то больше, например задание приоритета или имени потока, то можно создать класс с реализацией этого интерфейса и передать его в ThreadPoolExecutor.<br/>
<br/>
<b> RejectedExecutionHandler <img src="https://habrastorage.org/storage2/36b/c31/fa2/36bc31fa2bdf7a08f3a85dff79ee4eef.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — Позволяет определить обработчик для задач, которые по каким то причинам не могут быть выполнены через ThreadPoolExecutor. Такой случай может произойти, когда нет свободных потоков или сервис выключается или выключен (shutdown). Несколько стандартных имплементаций находятся в классе ThreadPoolExecutor: CallerRunsPolicy — запускает задачу в вызывающем потоке; AbortPolicy — кидает эксцепшен; DiscardPolicy — игнорирует задачу; DiscardOldestPolicy — удаляет самую старую незапущенную задачу из очереди, затем пытается добавить новую задачу еще раз.<br/>
<br/>
<h4>Fork Join</h4><br/>
<img src="https://habrastorage.org/storage2/442/afd/335/442afd335b6fc6bf036109c65c4821c5.png"/><br/>
<br/>
В java 1.7 появился новый Fork Join фреймворк для решения рекурсивных задач, работающих по алгоритмам <a href="http://en.wikipedia.org/wiki/Divide_and_conquer_algorithm">разделяй и влавствуй</a> или <a href="http://ru.wikipedia.org/wiki/MapReduce">Map Reduce</a>. Чтобы было более наглядней, можно привести визуальный пример алгоритма сортировки quicksort:<br/>
<a href="http://en.wikipedia.org/wiki/Quicksort"><img src="https://habrastorage.org/getpro/habr/post_images/32b/7ee/094/32b7ee0946a84e4038f357a4b668d5ad.gif"/></a><br/>
Так, за счет разбиения на части, можно добиться их параллельной обработки в разных потоках. Для решения этой задачи можно использовать и обычный ThreadPoolExecutor, но за счет частого переключения контекста и отслеживания контроля исполнения все это не очень эффективно работает. Тут то нам приходит на помощь Fork Join framework в основу которого используется <a href="http://classes.engineering.wustl.edu/cse566s/presentations/WorkStealing.pdf">work-stealing</a> алгоритм. Наиболее хорошо раскрывает себя в системах с большим количеством процессоров. Подробнее можно ознакомиться в блоге <a href="http://www.igvita.com/2012/02/29/work-stealing-and-recursive-partitioning-with-fork-join/">тут</a> или <a href="http://gee.cs.oswego.edu/dl/papers/fj.pdf">публикации</a> Doug Lea. Про производительность и масштабируемость можно почитать <a href="http://letitcrash.com/post/17607272336/scalability-of-fork-join-pool">тут</a>.<br/>
<br/>
<b> ForkJoinPool <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/968/b76/9b1/968b769b1a83359a83e5fd169d8dbde4.png"/></b> — Представляет собой точку входа для запуска корневых (main) ForkJoinTask задач. Подзадачи запускаются через методы задачи, от которой нужно отстрелиться (fork). По умолчанию создается пул потоков с количеством потоков равным количеству доступных для JVM процессоров (cores).<br/>
<br/>
<b> ForkJoinTask <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/93e/530/ead/93e530ead57ae1e70e6d067602e05095.png"/> <img src="https://habrastorage.org/storage2/968/b76/9b1/968b769b1a83359a83e5fd169d8dbde4.png"/></b> — Базовый класс для всех Fork Join задач. Из ключевых методов можно отметить: fork() — добавляет задачу в очередь текущего потока ForkJoinWorkerThread для асинхронного выполнения; invoke() — запускает задачу в текущем потоке; join() — ожидает завершения подзадачи с возвращением результата; invokeAll(...) — объединяет все три предыдущие предыдущие операции, выполняя две или более задач за один заход; adapt(...) — создает новую задачу ForkJoinTask из Runnable или Callable объектов.<br/>
<br/>
<b> RecursiveTask <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/93e/530/ead/93e530ead57ae1e70e6d067602e05095.png"/> <img src="https://habrastorage.org/storage2/968/b76/9b1/968b769b1a83359a83e5fd169d8dbde4.png"/></b> — Абстрактный класс от ForkJoinTask, с объявлением метода compute, в котором должна производиться асинхронная операция в наследнике.<br/>
<br/>
<b> RecursiveAction <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/93e/530/ead/93e530ead57ae1e70e6d067602e05095.png"/> <img src="https://habrastorage.org/storage2/968/b76/9b1/968b769b1a83359a83e5fd169d8dbde4.png"/></b> — Отличается от RecursiveTask тем, не возвращает результат.<br/>
<br/>
<b> ForkJoinWorkerThread <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/968/b76/9b1/968b769b1a83359a83e5fd169d8dbde4.png"/></b> — Используется в качестве имплементации по умолчанию в ForkJoinPoll. При желании можно отнаследоваться и перегрузить методы инициализации и завершения worker потока. <br/>
<br/>
<h4>Completion Service</h4><br/>
<img src="https://habrastorage.org/storage2/d26/de6/de1/d26de6de112cf6e1b8475162e54016c4.png"/><br/>
<br/>
<b> CompletionService <img src="https://habrastorage.org/storage2/36b/c31/fa2/36bc31fa2bdf7a08f3a85dff79ee4eef.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — Интерфейс сервиса с развязкой запуска асинхронных задач и получением результатов. Так, для добавления задач используются методы submit, а для вытаскивания результатов <i>завершенных</i> задач используются блокирующий метод take и неблокирующий poll. <br/>
<br/>
<b> ExecutorCompletionService <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — По сути является враппером над любым классом, реализующим интерфейс Executor, например ThreadPoolExecutor или ForkJoinPool. Используется преимущественно тогда, когда хочется абстрагироваться от способа запуска задач и контроля за их исполнением. Если есть завершенные задачи — вытаскиваем их, если нет — ждем в take пока что-нибудь не завершится. В основе сервиса по умолчанию используется LinkedBlockingQueue, но может быть передана и любая другая имплементация BlockingQueue.<br/>
<br/>
<br/>
<br/>
<h1>5. Locks</h1><br/>
<img src="https://habrastorage.org/storage2/4f1/edf/0f8/4f1edf0f8640f54475bf37ff72d04895.png"/><br/>
<br/>
<b> Condition <img src="https://habrastorage.org/storage2/36b/c31/fa2/36bc31fa2bdf7a08f3a85dff79ee4eef.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — Интерфейс, который описывает альтернативные методы стандарным wait/notify/notifyAll. Объект с условием чаще всего получается из локов через метод lock.newCondition(). Тем самым можно получить несколько комплектов wait/notify для одного объекта.<br/>
<br/>
<b> Lock <img src="https://habrastorage.org/storage2/36b/c31/fa2/36bc31fa2bdf7a08f3a85dff79ee4eef.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — Базовый интерфейс из lock framework, предоставляющий более гибкий подход по ограничению доступа к ресурсам/блокам нежели при использовании synchronized. Так, при использовании нескольких локов, порядок их освобождения может быть произвольный. Плюс имеется возможность пойти по альтернативному сценарию, если лок уже кем то захвачен.<br/>
<br/>
<b> ReentrantLock <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — Лок на вхождение. Только один поток может зайти в защищенный блок. Класс поддерживает «честную» (fair) и «нечестную» (non-fair) разблокировку потоков. При «честной» разблокировке соблюдается порядок освобождения потоков, вызывающих lock(). При «нечестной» разблокировке порядок освобождения потоков не гарантируется, но, как бонус, такая разблокировка работает быстрее. По умолчанию, используется «нечестная» разблокировка.<br/>
<br/>
<b> ReadWriteLock <img src="https://habrastorage.org/storage2/36b/c31/fa2/36bc31fa2bdf7a08f3a85dff79ee4eef.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — Дополнительный интерфейс для создания read/write локов. Такие локи необычайно полезны, когда в системе много операций чтения и мало операций записи.<br/>
<br/>
<b> ReentrantReadWriteLock <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — Очень часто используется в многопоточных сервисах и кешах, показывая очень хороший прирост производительности по сравнению с блоками synchronized. По сути, класс работает в 2-х взаимоисключающих режимах: много reader'ов читают данные в параллель и когда только 1 writer пишет данные. <br/>
<br/>
<b> ReentrantReadWriteLock.ReadLock <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — Read lock для reader'ов, получаемый через readWriteLock.readLock().<br/>
<br/>
<b> ReentrantReadWriteLock.WriteLock <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — Write lock для writer'ов, получаемый через readWriteLock.writeLock().<br/>
<br/>
<b> LockSupport <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — Предназначен для построения классов с локами. Содержит методы для парковки потоков вместо устаревших методов Thread.suspend() и Thread.resume().<br/>
<br/>
<img src="https://habrastorage.org/storage2/928/8f8/e77/9288f8e777b62ff96c4c953471e27f60.png"/><br/>
<br/>
<b> AbstractOwnableSynchronizer <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/c29/5ad/47f/c295ad47f86291abd7e8fe2b91b9621c.png"/></b> — Базовый класс для построения механизмов сихнронизации. Содержит всего одну пару геттер/сеттер для запоминания и чтения эксклюзивного потока, который может работать с данными.<br/>
<br/>
<b> AbstractQueuedSynchronizer <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — Используется в качестве базового класса для механизма синхронизации в FutureTask, CountDownLatch, Semaphore, ReentrantLock, ReentrantReadWriteLock. Может применяться при создании новых механизмов синхронизации, полагающихся на одиночное и атомарное значение int.<br/>
<br/>
<b> AbstractQueuedLongSynchronizer <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/c29/5ad/47f/c295ad47f86291abd7e8fe2b91b9621c.png"/></b> — Разновидность AbstractQueuedSynchronizer, которая поддерживает атомарное значение long.<br/>
<br/>
<br/>
<br/>
<h1>6. Atomics</h1><br/>
<img src="https://habrastorage.org/storage2/5be/563/489/5be563489a039bcb4033edecd3ed0cca.png"/><br/>
<br/>
<b> AtomicBoolean</b>, <b>AtomicInteger</b>, <b>AtomicLong</b>, <b>AtomicIntegerArray</b>, <b>AtomicLongArray <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — Что если в классе нужно синхронизировать доступ к одной простой переменной типа int? Можно использовать конструкции с synchronized, а при использовании атомарных операций set/get, подойдет также и volatile. Но можно поступить еще лучше, использовав новые классы Atomic*. За счет использования <a href="http://en.wikipedia.org/wiki/Compare-and-swap">CAS</a>, операции с этими классами работают быстрее, чем если синхронизироваться через synchronized/volatile. Плюс существуют методы для атомарного добавления на заданную величину, а также инкремент/декремент.<br/>
<br/>
<b> AtomicReference <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — Класс для атомарных операцией с ссылкой на объект.<br/>
<br/>
<b> AtomicMarkableReference <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — Класс для атомарных операцией со следующей парой полей: ссылка на объект и битовый флаг (true/false).<br/>
<br/>
<b> AtomicStampedReference <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — Класс для атомарных операцией со следующей парой полей: ссылка на объект и int значение.<br/>
<br/>
<b> AtomicReferenceArray <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — Массив ссылок на объекты, который может атомарно обновляться.<br/>
<br/>
<b> AtomicIntegerFieldUpdater</b>, <b>AtomicLongFieldUpdater</b>,<b>AtomicReferenceFieldUpdater <img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"/> <img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"/></b> — Классы для атомарного обновления полей по их именам через reflection. Смещение полей для CAS определяется в конструкторе и кешируются, т.ч. тут нет сильного падения производительности из за reflection.<br/>
<br/>


Статья 10

Многопоточность в Java. Часть І




Здравствуйте! В этой статье я вкратце расскажу вам о процессах, потоках, и об основах многопоточного программирования на языке Java. <img src="https://habrastorage.org/storage2/b5c/4b5/11a/b5c4b511ab0e9f4356df2bad7bb4b5f3.png" align="left"/> <br/>
Наиболее очевидная область применения многопоточности – это программирование интерфейсов. Многопоточность незаменима тогда, когда необходимо, чтобы графический интерфейс продолжал отзываться на действия пользователя во время выполнения некоторой обработки информации. Например, поток, отвечающий за интерфейс, может ждать завершения другого потока, загружающего файл из интернета, и в это время выводить некоторую анимацию или обновлять прогресс-бар. Кроме того он может остановить поток загружающий файл, если была нажата кнопка «отмена».<br/>
<br/>
Еще одна популярная и, пожалуй, одна из самых хардкорных областей применения многопоточности – игры. В играх различные потоки могут отвечать за работу с сетью, анимацию, расчет физики и т.п.<br/>
<br/>
Давайте начнем. Сначала о процессах.<br/>
<a name="habracut"></a><br/>
<h4>Процессы</h4><br/>
Процесс — это совокупность кода и данных, разделяющих общее виртуальное адресное пространство. Чаще всего одна программа состоит из одного процесса, но бывают и исключения (например, браузер Chrome создает отдельный процесс для каждой вкладки, что дает ему некоторые преимущества, вроде независимости вкладок друг от друга). Процессы изолированы друг от друга, поэтому прямой доступ к памяти чужого процесса невозможен (взаимодействие между процессами осуществляется с помощью специальных средств).<br/>
<br/>
Для каждого процесса ОС создает так называемое «виртуальное адресное пространство», к которому процесс имеет прямой доступ. Это пространство принадлежит процессу, содержит только его данные и находится в полном его распоряжении. Операционная система же отвечает за то, как виртуальное пространство процесса проецируется на физическую память.<br/>
<br/>
Схема этого взаимодействия представлена на картинке. Операционная система оперирует так называемыми страницами памяти, которые представляют собой просто область определенного фиксированного размера. Если процессу становится недостаточно памяти, система выделяет ему дополнительные страницы из физической памяти. Страницы виртуальной памяти могут проецироваться на физическую память в произвольном порядке.<br/>
<br/>
<div style="text-align:center;"><img src="https://habrastorage.org/storage2/c37/835/c12/c37835c1280215a60671823d0007e41f.png" /></div><br/>
<br/>
При запуске программы операционная система создает процесс, загружая в его адресное пространство код и данные программы, а затем запускает главный поток созданного процесса.<br/>
<br/>
<h4>Потоки</h4><br/>
Один поток – это одна единица исполнения кода. Каждый поток последовательно выполняет инструкции процесса, которому он принадлежит, параллельно с другими потоками этого процесса.<br/>
<br/>
Следует отдельно обговорить фразу «параллельно с другими потоками». Известно, что на одно ядро процессора, в каждый момент времени, приходится одна единица исполнения. То есть одноядерный процессор может обрабатывать команды только последовательно, по одной за раз (в упрощенном случае). Однако запуск нескольких параллельных потоков возможен и в системах с одноядерными процессорами. В этом случае система будет периодически переключаться между потоками, поочередно давая выполняться то одному, то другому потоку. Такая схема называется псевдо-параллелизмом. Система запоминает состояние (контекст) каждого потока, перед тем как переключиться на другой поток, и восстанавливает его по возвращению к выполнению потока. В контекст потока входят такие параметры, как стек, набор значений регистров процессора, адрес исполняемой команды и прочее…<br/>
<br/>
Проще говоря, при псевдопараллельном выполнении потоков процессор мечется между выполнением нескольких потоков, выполняя по очереди часть каждого из них.<br/>
<br/>
Вот как это выглядит:<br/>
<br/>
<img src="https://habrastorage.org/storage2/b26/e6d/c2c/b26e6dc2c8fb51acc03a76ead0c3abd8.png"/><br/>
<br/>
Цветные квадраты на рисунке – это инструкции процессора (зеленые – инструкции главного потока, синие – побочного). Выполнение идет слева направо. После запуска побочного потока его инструкции начинают выполняться вперемешку с инструкциями главного потока. Кол-во выполняемых инструкций за каждый подход не определено. <br/>
<br/>
То, что инструкции параллельных потоков выполняются вперемешку, в некоторых случаях может привести к конфликтам доступа к данным. Проблемам взаимодействия потоков будет посвящена следующая статья, а пока о том, как запускаются потоки в Java…<br/>
<br/>
<h4>Запуск потоков</h4><br/>
Каждый процесс имеет хотя бы один выполняющийся поток. Тот поток, с которого начинается выполнение программы, называется главным. В языке Java, после создания процесса, выполнение главного потока начинается с метода main(). Затем, по мере необходимости, в заданных программистом местах, и при выполнении заданных им же условий, запускаются другие, побочные потоки.<br/>
<br/>
В языке Java поток представляется в виде объекта-потомка класса Thread. Этот класс инкапсулирует стандартные механизмы работы с потоком.<br/>
<br/>
Запустить новый поток можно двумя способами:<br/>
<br/>
<h6>Способ 1</h6><br/>
Создать объект класса Thread, передав ему в конструкторе нечто, реализующее интерфейс Runnable. Этот интерфейс содержит метод run(), который будет выполняться в новом потоке. Поток закончит выполнение, когда завершится его метод run().<br/>
<br/>
Выглядит это так:<br/>
<br/>
<pre><code class="java">class SomeThing			//Нечто, реализующее интерфейс Runnable
implements Runnable		//(содержащее метод run())
{
	public void run()		//Этот метод будет выполняться в побочном потоке
	{
		System.out.println(&quot;Привет из побочного потока!&quot;);
	}
}

public class Program			//Класс с методом main()
{
	static SomeThing mThing;	//mThing - объект класса, реализующего интерфейс Runnable

	public static void main(String[] args)
	{
		mThing = new SomeThing();

		Thread myThready = new Thread(mThing);	//Создание потока &quot;myThready&quot;
		myThready.start();				//Запуск потока

		System.out.println(&quot;Главный поток завершён...&quot;);
	}
}
</code></pre><br/>
<br/>
Для пущего укорочения кода можно передать в конструктор класса Thread объект безымянного внутреннего класса, реализующего интерфейс Runnable:<br/>
<br/>
<pre><code class="java">public class Program		//Класс с методом main().
{
	public static void main(String[] args)
	{
		//Создание потока
		Thread myThready = new Thread(new Runnable()
		{
			public void run() //Этот метод будет выполняться в побочном потоке
			{
				System.out.println(&quot;Привет из побочного потока!&quot;);
			}
		});
		myThready.start();	//Запуск потока

		System.out.println(&quot;Главный поток завершён...&quot;);
	}
}
</code></pre><br/>
<br/>
<h6>Способ 2</h6><br/>
Создать потомка класса Thread и переопределить его метод run():<br/>
<br/>
<pre><code class="java">class AffableThread extends Thread
{
	@Override
	public void run()	//Этот метод будет выполнен в побочном потоке
	{
		System.out.println(&quot;Привет из побочного потока!&quot;);
	}
}

public class Program
{
	static AffableThread mSecondThread;

	public static void main(String[] args)
	{
		mSecondThread = new AffableThread();	//Создание потока
		mSecondThread.start();					//Запуск потока

		System.out.println(&quot;Главный поток завершён...&quot;);
	}
}
</code></pre><br/>
<br/>
В приведённом выше примере в методе main() создается и запускается еще один поток. Важно отметить, что после вызова метода mSecondThread.start() главный поток продолжает своё выполнение, не дожидаясь пока порожденный им поток завершится. И те инструкции, которые идут после вызова метода start(), будут выполнены параллельно с инструкциями потока mSecondThread.<br/>
<br/>
Для демонстрации параллельной работы потоков давайте рассмотрим программу, в которой два потока спорят на предмет философского вопроса «что было раньше, яйцо или курица?». Главный поток уверен, что первой была курица, о чем он и будет сообщать каждую секунду. Второй же поток раз в секунду будет опровергать своего оппонента. Всего спор продлится 5 секунд. Победит тот поток, который последним изречет свой ответ на этот, без сомнения, животрепещущий философский вопрос. В примере используются средства, о которых пока не было сказано (isAlive() sleep() и join()). К ним даны комментарии, а более подробно они будут разобраны дальше.<br/>
<br/>
<pre><code class="java">class EggVoice extends Thread
{
	@Override
	public void run()
	{
		for(int i = 0; i &lt; 5; i++)
		{
			try{
				sleep(1000);		//Приостанавливает поток на 1 секунду
			}catch(InterruptedException e){}

			System.out.println(&quot;яйцо!&quot;);
		}
		//Слово «яйцо» сказано 5 раз
	}
}

public class ChickenVoice	//Класс с методом main()
{
	static EggVoice mAnotherOpinion;	//Побочный поток

	public static void main(String[] args)
	{
		mAnotherOpinion = new EggVoice();	//Создание потока
		System.out.println(&quot;Спор начат...&quot;);
		mAnotherOpinion.start(); 			//Запуск потока

		for(int i = 0; i &lt; 5; i++)
		{
			try{
				Thread.sleep(1000);		//Приостанавливает поток на 1 секунду
			}catch(InterruptedException e){}

			System.out.println(&quot;курица!&quot;);
		}

		//Слово «курица» сказано 5 раз

		if(mAnotherOpinion.isAlive())	//Если оппонент еще не сказал последнее слово
		{
			try{
				mAnotherOpinion.join();	//Подождать пока оппонент закончит высказываться.
			}catch(InterruptedException e){}

			System.out.println(&quot;Первым появилось яйцо!&quot;);
		}
		else	//если оппонент уже закончил высказываться
		{
			System.out.println(&quot;Первой появилась курица!&quot;);
		}
		System.out.println(&quot;Спор закончен!&quot;);
	}
}

Консоль:
Спор начат...
курица!
яйцо!
яйцо!
курица!
яйцо!
курица!
яйцо!
курица!
яйцо!
курица!
Первой появилась курица!
Спор закончен!
</code></pre><br/>
<br/>
В приведенном примере два потока параллельно в течении 5 секунд выводят информацию на консоль. Точно предсказать, какой поток закончит высказываться последним, невозможно. Можно попытаться, и можно даже угадать, но есть большая вероятность того, что та же программа при следующем запуске будет иметь другого «победителя». Это происходит из-за так называемого «асинхронного выполнения кода». Асинхронность означает то, что нельзя утверждать, что какая-либо инструкция одного потока, выполнится раньше или позже инструкции другого. Или, другими словами, параллельные потоки независимы друг от друга, за исключением тех случаев, когда программист сам описывает зависимости между потоками с помощью предусмотренных для этого средств языка.<br/>
<br/>
Теперь немного о завершении процессов…<br/>
<br/>
<h4>Завершение процесса и демоны</h4><br/>
В Java процесс завершается тогда, когда завершается последний его поток. Даже если метод main() уже завершился, но еще выполняются порожденные им потоки, система будет ждать их завершения.<br/>
<br/>
Однако это правило не относится к особому виду потоков – демонам. Если завершился последний обычный поток процесса, и остались только потоки-демоны, то они будут принудительно завершены и выполнение процесса закончится. Чаще всего потоки-демоны используются для выполнения фоновых задач, обслуживающих процесс в течение его жизни.<br/>
<br/>
Объявить поток демоном достаточно просто — нужно перед запуском потока вызвать его метод <b><code>setDaemon(true)</code></b>;<br/>
Проверить, является ли поток демоном, можно вызвав его метод <b><code>boolean isDaemon()</code></b>;<br/>
<br/>




Статья 11

Многопоточность в Java. Часть ІІ



<h4>Завершение потоков</h4><br/>
В Java существуют (существовали) средства для принудительного завершения потока. В частности метод Thread.stop() завершает поток незамедлительно после своего выполнения. Однако этот метод, а также Thread.suspend(), приостанавливающий поток, и Thread.resume(), продолжающий выполнение потока, были объявлены устаревшими и их использование отныне крайне нежелательно. Дело в том что поток может быть «убит» во время выполнения операции, обрыв которой на полуслове оставит некоторый объект в неправильном состоянии, что приведет к появлению трудноотлавливаемой и случайным образом возникающей ошибке.<br/>
<br/>
Вместо принудительного завершения потока применяется схема, в которой каждый поток сам ответственен за своё завершение. Поток может остановиться либо тогда, когда он закончит выполнение метода run(), (main() — для главного потока) либо по сигналу из другого потока. Причем как реагировать на такой сигнал — дело, опять же, самого потока. Получив его, поток может выполнить некоторые операции и завершить выполнение, а может и вовсе его проигнорировать и продолжить выполняться. Описание реакции на сигнал завершения потока лежит на плечах программиста.<br/>
<br/>
Java имеет встроенный механизм оповещения потока, который называется Interruption (прерывание, вмешательство), и скоро мы его рассмотрим, но сначала посмотрите на следующую программку:<br/>
<br/>
Incremenator — поток, который каждую секунду прибавляет или вычитает единицу из значения статической переменной Program.mValue. Incremenator содержит два закрытых поля – mIsIncrement и mFinish. То, какое действие выполняется, определяется булевой переменной mIsIncrement — если оно равно true, то выполняется прибавление единицы, иначе — вычитание. А завершение потока происходит, когда значение mFinish становится равно true.<br/>
<br/>
<pre><code class="java">class Incremenator extends Thread
{
	//О ключевом слове volatile - чуть ниже
	private volatile boolean mIsIncrement = true;
	private volatile boolean mFinish = false;

	public void changeAction()	//Меняет действие на противоположное
	{
		mIsIncrement = !mIsIncrement;
	}
	public void finish()		//Инициирует завершение потока
	{
		mFinish = true;
	}

	@Override
	public void run()
	{
		do
		{
			if(!mFinish)	//Проверка на необходимость завершения
			{
				if(mIsIncrement)
					Program.mValue++;	//Инкремент
				else
					Program.mValue--;	//Декремент

				//Вывод текущего значения переменной
				System.out.print(Program.mValue + &quot; &quot;);
			}
			else
				return;		//Завершение потока

			try{
				Thread.sleep(1000);		//Приостановка потока на 1 сек.
			}catch(InterruptedException e){}
		}
		while(true);
	}
}

public class Program
{
	//Переменая, которой оперирует инкременатор
	public static int mValue = 0;

	static Incremenator mInc;	//Объект побочного потока

	public static void main(String[] args)
	{
		mInc = new Incremenator();	//Создание потока

		System.out.print(&quot;Значение = &quot;);

		mInc.start();	//Запуск потока

		//Троекратное изменение действия инкременатора
		//с интервалом в i*2 секунд
		for(int i = 1; i &lt;= 3; i++)
		{
			try{
				Thread.sleep(i*2*1000); //Ожидание в течении i*2 сек.
			}catch(InterruptedException e){}

			mInc.changeAction();	//Переключение действия
		}

		mInc.finish();	//Инициация завершения побочного потока
	}
}

Консоль:
Значение = 1 2 1 0 -1 -2 -1 0 1 2 3 4
</code></pre><br/>
<br/>
Взаимодействовать с потоком можно с помощью метода changeAction() (для смены вычитания на сложение и наоборот) и метода finish() (для завершения потока).<br/>
<br/>
В объявлении переменных mIsIncrement и mFinish было использовано ключевое слово volatile (изменчивый, не постоянный). Его необходимо использовать для переменных, которые используются разными потоками. Это связано с тем, что значение переменной, объявленной без volatile, может кэшироваться отдельно для каждого потока, и значение из этого кэша может различаться для каждого из них. Объявление переменной с ключевым словом volatile отключает для неё такое кэширование и все запросы к переменной будут направляться непосредственно в память.<br/>
<br/>
В этом примере показано, каким образом можно организовать взаимодействие между потоками. Однако есть одна проблема при таком подходе к завершению потока — Incremenator проверяет значение поля mFinish раз в секунду, поэтому может пройти до секунды времени между тем, когда будет выполнен метод finish(), и фактическим завершения потока. Было бы замечательно, если бы при получении сигнала извне, метод sleep() возвращал выполнение и поток незамедлительно начинал своё завершение. Для выполнения такого сценария существует встроенное средство оповещения потока, которое называется Interruption (прерывание, вмешательство).<br/>
<br/>
<h4>Interruption</h4><br/>
Класс Thread содержит в себе скрытое булево поле, подобное полю mFinish в программе Incremenator, которое называется флагом прерывания. Установить этот флаг можно вызвав метод interrupt() потока. Проверить же, установлен ли этот флаг, можно двумя способами. Первый способ — вызвать метод bool isInterrupted() объекта потока, второй — вызвать статический метод bool Thread.interrupted(). Первый метод возвращает состояние флага прерывания и оставляет этот флаг нетронутым. Второй метод возвращает состояние флага и сбрасывает его. Заметьте что Thread.interrupted() — статический метод класса Thread, и его вызов возвращает значение флага прерывания того потока, из которого он был вызван. Поэтому этот метод вызывается только изнутри потока и позволяет потоку проверить своё состояние прерывания.<br/>
<br/>
Итак, вернемся к нашей программе. Механизм прерывания позволит нам решить проблему с засыпанием потока. У методов, приостанавливающих выполнение потока, таких как sleep(), wait() и join() есть одна особенность — если во время их выполнения будет вызван метод interrupt() этого потока, они, не дожидаясь конца времени ожидания, сгенерируют исключение InterruptedException.<br/>
<br/>
Переделаем программу Incremenator – теперь вместо завершения потока с помощью метода finish() будем использовать стандартный метод interrupt(). А вместо проверки флага mFinish будем вызывать метод bool Thread.interrupted();<br/>
Так будет выглядеть класс Incremenator после добавления поддержки прерываний:<br/>
<br/>
<pre><code class="java">class Incremenator extends Thread
{
	private volatile boolean mIsIncrement = true;

	public void changeAction()	//Меняет действие на противоположное
	{
		mIsIncrement = !mIsIncrement;
	}

	@Override
	public void run()
	{
		do
		{
			if(!Thread.interrupted())	//Проверка прерывания
			{
				if(mIsIncrement) Program.mValue++;	//Инкремент
				else Program.mValue--;			//Декремент

				//Вывод текущего значения переменной
				System.out.print(Program.mValue + &quot; &quot;);
			}
			else
				return;		//Завершение потока

			try{
				Thread.sleep(1000);		//Приостановка потока на 1 сек.
			}catch(InterruptedException e){
				return;	//Завершение потока после прерывания
			}
		}
		while(true);
	}
}

class Program
{
	//Переменая, которой оперирует инкременатор
	public static int mValue = 0;

	static Incremenator mInc;	//Объект побочного потока

	public static void main(String[] args)
	{
		mInc = new Incremenator();	//Создание потока

		System.out.print(&quot;Значение = &quot;);

		mInc.start();	//Запуск потока

		//Троекратное изменение действия инкременатора
		//с интервалом в i*2 секунд
		for(int i = 1; i &lt;= 3; i++)
		{
			try{
				Thread.sleep(i*2*1000);		//Ожидание в течении i*2 сек.
			}catch(InterruptedException e){}

			mInc.changeAction();	//Переключение действия
		}

		mInc.interrupt();	//Прерывание побочного потока
	}
}

Консоль:
Значение = 1 2 1 0 -1 -2 -1 0 1 2 3 4
</code></pre><br/>
<br/>
Как видите, мы избавились от метода finish() и реализовали тот же механизм завершения потока с помощью встроенной системы прерываний. В этой реализации мы получили одно преимущество — метод sleep() вернет управление (сгенерирует исключение) незамедлительно после прерывания потока.<br/>
<br/>
Заметьте что методы sleep() и join() обёрнуты в конструкции try-catch. Это необходимое условие работы этих методов. Вызывающий их код должен перехватывать исключение InterruptedException, которое они бросают при прерывании во время ожидания.<br/>
<br/>
С запуском и завершением потоков разобрались, дальше я расскажу о методах, использующихся при работе с потоками.<br/>
<br/>
<h4>Метод Thread.sleep()</h4><br/>
Thread.sleep() — статический метод класса Thread, который приостанавливает выполнение потока, в котором он был вызван. Во время выполнения метода sleep() система перестает выделять потоку процессорное время, распределяя его между другими потоками. Метод sleep() может выполняться либо заданное кол-во времени (миллисекунды или наносекунды) либо до тех пор пока он не будет остановлен прерыванием (в этом случае он сгенерирует исключение InterruptedException).<br/>
<br/>
<pre><code class="java">Thread.sleep(1500); 		//Ждет полторы секунды
Thread.sleep(2000, 100);  	//Ждет 2 секунды и 100 наносекунд
</code></pre><br/>
<br/>
Несмотря на то, что метод sleep() может принимать в качестве времени ожидания наносекунды, не стоит принимать это всерьез. Во многих системах время ожидания все равно округляется до миллисекунд а то и до их десятков. <br/>
<br/>
<h4>Метод yield()</h4><br/>
Статический метод Thread.yield() заставляет процессор переключиться на обработку других потоков системы. Метод может быть полезным, например, когда поток ожидает наступления какого-либо события и необходимо чтобы проверка его наступления происходила как можно чаще. В этом случае можно поместить проверку события и метод Thread.yield() в цикл:<br/>
<br/>
<pre><code class="java">//Ожидание поступления сообщения
while(!msgQueue.hasMessages())		//Пока в очереди нет сообщений
{
	Thread.yield();		//Передать управление другим потокам
}
</code></pre><br/>
<br/>
<h4>Метод join()</h4><br/>
В Java предусмотрен механизм, позволяющий одному потоку ждать завершения выполнения другого. Для этого используется метод join(). Например, чтобы главный поток подождал завершения побочного потока myThready, необходимо выполнить инструкцию myThready.join() в главном потоке. Как только поток myThready завершится, метод join() вернет управление, и главный поток сможет продолжить выполнение.<br/>
<br/>
Метод join() имеет перегруженную версию, которая получает в качестве параметра время ожидания. В этом случае join() возвращает управление либо когда завершится ожидаемый поток, либо когда закончится время ожидания. Подобно методу Thread.sleep() метод join может ждать в течение миллисекунд и наносекунд – аргументы те же.<br/>
<br/>
С помощью задания времени ожидания потока можно, например, выполнять обновление анимированной картинки пока главный (или любой другой) поток ждёт завершения побочного потока, выполняющего ресурсоёмкие операции:<br/>
<br/>
<pre><code class="java">Thinker brain = new Thinker(); 	//Thinker - потомок класса Thread.
brain.start();		//Начать &quot;обдумывание&quot;.

do
{
	mThinkIndicator.refresh();		//mThinkIndicator - анимированная картинка.

	try{
		brain.join(250);				//Подождать окончания мысли четверть секунды.
	}catch(InterruptedException e){}
}
while(brain.isAlive());	//Пока brain думает...

//brain закончил думать (звучат овации).
</code></pre><br/>
<br/>
В этом примере поток brain (мозг) думает над чем-то, и предполагается, что это занимает у него длительное время. Главный поток ждет его четверть секунды и, в случае, если этого времени на раздумье не хватило, обновляет «индикатор раздумий» (некоторая анимированная картинка). В итоге, во время раздумий, пользователь наблюдает на экране индикатор мыслительного процесса, что дает ему знать, что электронные мозги чем то заняты.<br/>
<br/>
<h4>Приоритеты потоков</h4><br/>
Каждый поток в системе имеет свой приоритет. Приоритет – это некоторое число в объекте потока, более высокое значение которого означает больший приоритет. Система в первую очередь выполняет потоки с большим приоритетом, а потоки с меньшим приоритетом получают процессорное время только тогда, когда их более привилегированные собратья простаивают.<br/>
<br/>
Работать с приоритетами потока можно с помощью двух функций:<br/>
<br/>
<b><code>void setPriority(int priority)</code></b> – устанавливает приоритет потока.<br/>
Возможные значения priority — MIN_PRIORITY, NORM_PRIORITY и MAX_PRIORITY.<br/>
<br/>
<b><code>int getPriority()</code></b> – получает приоритет потока.<br/>
<br/>
<h4>Некоторые полезные методы класса Thread</h4><br/>
Это практически всё. Напоследок приведу несколько полезных методов работы с потоками.<br/>
<br/>
<b><code>boolean isAlive()</code></b> — возвращает true если myThready() выполняется и false если поток еще не был запущен или был завершен.<br/>
<br/>
<b><code>setName(String threadName)</code></b> – Задает имя потока.<br/>
<b><code>String getName()</code></b> – Получает имя потока.<br/>
Имя потока – ассоциированная с ним строка, которая в некоторых случаях помогает понять, какой поток выполняет некоторое действие. Иногда это бывает полезным.<br/>
<br/>
<b><code>static Thread Thread.currentThread()</code></b> — статический метод, возвращающий объект потока, в котором он был вызван.<br/>
<br/>
<b><code>long getId()</code></b>– возвращает идентификатор потока. Идентификатор – уникальное число, присвоенное потоку.<br/>
<br/>
<h4>Заключение</h4><br/>
Отмечу, что в статье рассказано далеко не про все нюансы многопоточного программирования. И коду, приведенному в примерах, для полной корректности не хватает некоторых нюансов. В частности, в примерах не используется синхронизация. Синхронизация потоков — тема, не изучив которую, программировать правильные многопоточные приложения не получится. Почитать о ней вы можете, например, в книге «Java Concurrency in Practice» или <a href="http://docs.oracle.com/javase/tutorial/essential/concurrency/">здесь</a> (всё на английском).<br/>
<br/>
В статье были рассмотрены основные средства работы с потоками в Java. Если эта статья окажется полезной, то в следующей я расскажу о проблемах совместного доступа потоков к ресурсам и о методах их решения.<br/>
<br/>
Всех благ.
